The "Modified Preferences" list shown on about:support gives way too much information about users. Several prefs can be used to gather various private information bits about users including download directory, printer names/IPs, filenames of downloaded files.

Just looking through some of my personal prefs, I see the following prefs that can compromise personal information:
* browser.download.lastDir -- compromises home directory
* print.print_to_filename (various print.*.print_to_filename) -- compromises filename of last file downloaded using print-to-file
* print.* -- compromises printer names and/or IPs

This becomes really bad when combined with extensions that store personal information such as usernames and passwords in prefs for use. We're making it way too easy for this type of data to be accidentally released to others.

This list of modified prefs should just be removed for now. One possibility might be to restrict it to Firefox-only modified prefs with some blacklist for prefs that are known to contain personal data. That way, private information from prefs that extensions add is not compromised when users post this information on public forums.

The "Modified Preferences" list shown on about:support gives way too much information about users. Several prefs can be used to gather various private information bits about users including download directory, printer names/IPs, filenames of downloaded files.

Just looking through some of my personal prefs, I see the following prefs that can compromise personal information:
* browser.download.lastDir -- compromises home directory
* print.print_to_filename (various print.*.print_to_filename) -- compromises filename of last file downloaded using print-to-file
* print.* -- compromises printer names and/or IPs

This becomes really bad when combined with extensions that store personal information such as usernames and passwords in prefs for use. We're making it way too easy for this type of data to be accidentally released to others.

This list of modified prefs should just be removed for now. One possibility might be to restrict it to Firefox-only modified prefs with some blacklist for prefs that are known to contain personal data. That way, private information from prefs that extensions add is not compromised when users post this information on public forums.
This is not a "security" problem and does not need a [sg] whiteboard designation: about:support is not accessible to web content.

I'm sympathetic to the privacy argument, but this doesn't seem very different than the HijackThis or Malwarebytes output people willingly post on anti-malware forums.
Protecting users from themselves here (particularly vulnerable users who aren't very technical and who are engaging some third party in tech support - the very targets of this feature) is worthwhile, to say nothing of the higher signal/noise ratio it would represent for real support if only the "relevant" prefs were in the pasted output.

Having said that, I wouldn't hold the release of 3.6 for this. Users who can be victimized by this are, by definition, ripe targets for social engineering, in which case I think more direct approaches would work just fine ("I'm not seeing any problem here, but let me log on to the site as you and make sure - what's your username/password?")

I think the right thing to do here is get SUMO to comment on what makes more sense - a whitelist or a blacklist, and in either event, to provide the initial seed. Filtering the list is not a significant technological challenge.

To that end, copying in a few support people.
I'd actually recommend WONTFIX on this bug for a couple of reasons:

1. Whitelisting defeats the purpose of this. The modified preferences help the support group understand what add-ons are installed, and what they're doing. It's very instructive. If we feel that there are certain preferences which divulge private information which are *not* instructive (default download location, f.e., though that could obviously help a SUMO person answering the "where did my downloads go?" question) then we should blacklist, not whitelist.

2. The main worry here is a social hack, where a website fools you into pasting the content. It'd be pretty simple to add a warning the first time someone copies (either using the button or by using the clipboard) which lets users know that the information they copied contains potentially private information, and that they should trust the person who's asking for that information.

3. Any malicious add-on can gather this information already, as noted in comment 1.

There's some good stuff we can do here, but as expressed (removing the modified prefs list) I don't see how we'd ever resolve this bug as fixed.
(In reply to comment #1)
> I'm sympathetic to the privacy argument, but this doesn't seem very different
> than the HijackThis or Malwarebytes output people willingly post on
> anti-malware forums.

It's very different. As somebody who has assisted many users with dealing with viruses and the like, I know exactly what such output from HijackThis and Malwarebytes looks like, and it definitely doesn't include filenames of things downloaded, printer names/IPs, and usernames/passwords.

(In reply to comment #2)
> Having said that, I wouldn't hold the release of 3.6 for this. Users who can be
> victimized by this are, by definition, ripe targets for social engineering, in
> which case I think more direct approaches would work just fine ("I'm not seeing
> any problem here, but let me log on to the site as you and make sure - what's
> your username/password?")

I'm not sure how you can truthfully call bug 518601 a blocker while saying this bug doesn't block, as this bug is definitely more dangerous to the user than bug 518601. Considering users will unwittingly post this data on _public_ forums at the request of SUMO (or other forums) helpers, opening themselves up to abuse by attackers. Comment #0 lists some of the data that users would be posting, including filenames of things printed-to-PDF, printer names/IPs, path of home directory, and with the combination of add-ons, usernames and passwords. 

> I think the right thing to do here is get SUMO to comment on what makes more
> sense - a whitelist or a blacklist, and in either event, to provide the initial
> seed. Filtering the list is not a significant technological challenge.

I'm not saying I know what the right solution is. I'm just saying that as about:support currently stands, it's completely unacceptable to put users in this position where they are so easily compromised.

(In reply to comment #3)
> 1. Whitelisting defeats the purpose of this. The modified preferences help the
> support group understand what add-ons are installed, and what they're doing.
> It's very instructive. If we feel that there are certain preferences which
> divulge private information which are *not* instructive (default download
> location, f.e., though that could obviously help a SUMO person answering the
> "where did my downloads go?" question) then we should blacklist, not whitelist.

What about add-ons that post passwords into prefs? ... or the various other things that I've mentioned? SUMO helpers are having users post this information on a _public forum_ where attackers can easily see the information.

> 2. The main worry here is a social hack, where a website fools you into pasting
> the content. It'd be pretty simple to add a warning the first time someone
> copies (either using the button or by using the clipboard) which lets users
> know that the information they copied contains potentially private information,
> and that they should trust the person who's asking for that information.

Sure, I definitely think some type of warning message would be good in working to improve this. I still think users are being made vulnerable by this as a whole, though, especially without some changes.

> 3. Any malicious add-on can gather this information already, as noted in
> comment 1.

A malicious add-on isn't as easily installed or trusted as something that Firefox itself specifically offers to the user to use in troubleshooting and that is sanctioned by official Firefox support places.

> There's some good stuff we can do here, but as expressed (removing the modified
> prefs list) I don't see how we'd ever resolve this bug as fixed.

Again, I'm not saying I know what the right solution is... This bug is about improving the current about:support to something that is actually acceptable from a privacy standpoint.
currently this information is in a findable, human readable file.  People phishing for this information can get it already. IMO this listing doesn't harm users' privacy compared to the status quo, it just makes it easier for them to violate their own privacy.

SUMO doesn't have to display prefs publicly. Access could be limited to moderators. At the same time, SUMO could also give instructions for copying/pasting prefs from prefs.js

From my (limited) view it seems any privacy issues with this function are existing privacy issues that deserve looking at anyway.
(In reply to comment #5)
> currently this information is in a findable, human readable file.  People
> phishing for this information can get it already.

I'm not worried about the actual users getting this information. I'm worried about the bad guys who use the information that these users post online in order to exploit them.

> SUMO doesn't have to display prefs publicly. Access could be limited to
> moderators.

That would be useful, though it wouldn't stop some other help forum site from doing the same thing. Need a "fix" at the product-level, not _just_ the support level.
Reed, if you want this to block, it'll need to be more specific. As with Dan, I'm sympathetic to the privacy arguments, but right now there's no solution.

If you think there's a specific list of privacy-related preferences we should never show, let's get that list and then we can make a blocking decision on changing the code to not display that list. For now, as expressed, I can't block on this bug.
This bug makes about:support useless for support forums, by making it too dangerous to point users to.  If you can't be arsed to put together a whitelist for 3.6 then you should remove the prefs list from about:support in 3.6.  I'm angry that you turned this bug nebulous and then refused to block on it due to its nebulosity.
Also, while the proposed solutions may be nebulous, the *problem* is real and should remain a blocker.
How about just not showing any non-default extensions.* prefs?  Non-default as in ones not included with Firefox, so ones that were added by extensions...not ones changed by extensions.
We *could* do something like truncate the values when pasting, that way support people can see which values have been changed and see the first part, then they can ask back for the full values of specific prefs if needed. For the most part I believe we don't need the value, we just need to know if it's changed from default. We either have the user reset it or tell them what value it should be.

However, I can walk someone through posting all their prefs as it is right now. It takes a little longer but I don't think anyone would be less willing to share the file than they would be to copy/paste something from the browser.

I could also get at least some people to give me their password file and the key to decrypt them. There are no warnings anywhere. People sometimes throw their login info at you for a site they're having problems with even when you tell them not to. People will also install anything you tell them to. It's easy enough to get the cookie file, too.

As soon as a user trusts the wrong person they're screwed.
Marjken, we can't fix user ignorance but this is something we can fix.
But you're contradicting yourself.  This page in no way automates submitting the data without the user's control. The user still has to choose to submit the data to a malicious site.
Malicious comments in support forums has always been a potential problem, but it's detectable and I haven't heard of it happening on a large scale.

This is different.  With this bug, well-meaning supporters will cause some users' sensitive information to show up in web searches such as:

http://www.google.com/search?q="Application+Basics"+app.update.lastUpdateTime+password

With both the application and supporters encouraging users to copy the entire page, and with the prefs list being mostly boring technical jargon, even English-speaking users don't have a chance of noticing a username or password among their prefs.
Or maybe you're expecting supporters to tell users not to paste that part?  Or expecting users to read through the entire list before submitting it?  Either of those solutions would be a huge waste of time and still fail frequently.
(In reply to comment #13)
> But you're contradicting yourself.  This page in no way automates submitting
> the data without the user's control. The user still has to choose to submit the
> data to a malicious site.

What I meant by "we can't fix their ignorance" is that if some user in sweet talked into supplying their login information; there is nothing we can do to help that.

But we are now easily supplying the modified preference list with the values so the user can easily supply this information for support.  We can't stop the user from being talked into going to about:config, copy and pasting a preference with a value onto a forum but we can help by not making the user be able to easily and unknowingly supply this information while using this feature.

I have 388 modified preferences, there is no way I'm going to scan every single one to see if I have login information in there.  And If I wasn't a power user, I wouldn't even know that information could be in there.
(In reply to comment #8)
> This bug makes about:support useless for support forums, by making it too
> dangerous to point users to.  If you can't be arsed to put together a whitelist
> for 3.6 then you should remove the prefs list from about:support in 3.6.  I'm
> angry that you turned this bug nebulous and then refused to block on it due to
> its nebulosity.

Help me understand what parts of my comment 2 lead you to this feeling? If it wasn't my comments, but someone else's instead, then I think the main action here, right now, remains:

(In reply to comment #2)
> I think the right thing to do here is get SUMO to comment on what makes more
> sense - a whitelist or a blacklist, and in either event, to provide the initial
> seed. Filtering the list is not a significant technological challenge.

It's clear that the information is useful - it's also clear what the privacy concern is. It's almost certainly the case, I think, that a happy middle ground exists where we can have all the prefs we're most likely to need, and none of them will be particularly sensitive ones, but for that we need support to chime in with their opinion. I'd submit that channeling anger into energetic engagement with our support folk on getting that list together would be to everyone's benefit.
Thanks everyone for your passion and attention! The SUMO team discussed offline with cbartley, johnath and beltzner, and we agreed that the happy middle ground is a focused list of prefs (a whitelist) rather than the full list of modified prefs. That way we can control the "user ignorance"/privacy issue.

Based on Cheng and Matthew's experience with troubleshooting, the following list of prefs is suggested:

javascript.*
browser.zoom.*
keyword.*, browser.fixup.* (troubleshooting location bar search)
print.* (troubleshooting printers)
accessibility.* (caret mode and block auto refresh)
browser.download.dir (default download folder)
browser.places.*, browser.history*, places.*, privacy.* (bookmarks/history)
browser.startup.homepage
browser.startup.homepage_override.mstone (display "Firefox has been updated" tab)
dom.* (JS settings)
extensions.checkCompatibility, extensions.lastAppVersion (extensions that claim to not be compatible)
font.* (fonts too big/small)
gfx.color_management.mode (color profiles make images display differently from IE)
layout.css.dpi
network.* (settings often 'tweaked' by 'power users', plus cookie settings)
security.* (ssl/tls settings)
general.useragent.* (bad user-agents can break websites that do UA sniffing)

This should be a very good start and help us troubleshoot the most common issues with Firefox. If it turns out that some vital prefs are missing for troubleshooting, we can always add that in the next release.

Thanks!
(In reply to comment #18)
> Based on Cheng and Matthew's experience with troubleshooting, the following
> list of prefs is suggested:

Some additional ideas:
* browser.tabs.* (for browser.tabs.insertRelatedAfterCurrent and others)
* browser.link.open_newwindow, browser.link.open_newwindow.restriction
* browser.mousewheel.* (Maybe / maybe not? I could go either way.)
browser.download.dir probably shouldn't be included, because it reveals the OS username.  Worse, it's a nsILocalFile::persistentDescriptor, so Mac users won't be able to realize that what they're pasting includes their username (and possibly low-level filesystem details!).

Reed expressed concerns over print.* in comment 0, so I think those should also not be part of the whitelist for about:support.  If users often need help troubleshooting printer problems, it might make sense to create an about:printing and link there from about:support.

How long is a typical modified prefs list once it has run through the proposed whitelist?

You probably want the DPI even if layout.css.dpi is set to -1.
Created attachment 405632
preferences whitelist implementation, v1

A Preferences whitelist implementation, using the prefs and pref branches proposed in comment #18 and comment #19, and excluding browser.download.dir per comment #20 (but still including print.*).
Created attachment 405634
The current whitelist and the specific prefs it allows

The whitelist from the v1 patch and a list of the specific prefs that are allowed by the whitelist.  There are ~730 individual prefs that are allowed by this whitelist.
If you want to be extra paranoid you can check the whitelist against lists of prefs used by older versions of Firefox ;)  Since if they've been modified, they'll still be around.
If print.* has to stay, can print.print_to_filename and print.*.print_to_filename be blacklisted, at least?
(In reply to comment #22)
> Created an attachment (id=405634) [details]
> The current whitelist and the specific prefs it allows

Though "browser.mousewheel.*" is among the whitelist, I didn't see any mousewheel-related prefs within the list itself (?). 

(If you view attachment 405634 and do a Cmd-F for "mousewheel" the word only appears once, within the "current whitelist" part of the page.)

On a somewhat unrelated note, though I had originally brought up the idea about including 'browser.link.open_newwindow' and 'browser.link.open_newwindow.restriction' individually, it probably wouldn't hurt just to include browser.link.* as that would give us 'browser.link.open_external', too.
(In reply to comment #25)
> (In reply to comment #22)
> > Created an attachment (id=405634) [details] [details]
> > The current whitelist and the specific prefs it allows
> 
> Though "browser.mousewheel.*" is among the whitelist, I didn't see any
> mousewheel-related prefs within the list itself (?). 

I don't have any browser.mousewheel prefs period.  I do have some "mousewheel.*" prefs, but that's not on the whitelist.

It's a probably a good idea for somebody knowledgeable to double check the whitelist.

Also, as Jesse mentioned in comment #23, my list of affected prefs will be incomplete since there could be user prefs that are no longer used left over from previous versions of Firefox.
(In reply to comment #21)
> Created an attachment (id=405632) [details]
> preferences whitelist implementation, v1
> 
> A Preferences whitelist implementation, using the prefs and pref branches
> proposed in comment #18 and comment #19, and excluding browser.download.dir per
> comment #20 (but still including print.*).

Is there a reason not to just do this list as an array of (compiled) regexes? It would give us a little more flexibility in terms of the structure of the entries, and remove the need for post-processing the list, multiple dictionaries, and pref-name tokenizing that is going on here. 

At that point, I think all the PrefsWhiteList logic could just be replaced with:

   return whitelistRegexArray.every(function (re) {re.test(prefName);});

Or, if you want to address reed's request in comment 24, 

   return whitelistRegexArray.every(function (re) {re.test(prefName);})
          && !blacklistRegexArray.some(function (re) {re.test(prefName);});
mconnor points out that another, arguably more correct approach would be to just treat your list as a list of pref branches, and only walk those branches looking for modified prefs, instead of walking the whole world. Then, implicitly, no post-filtration is needed at all, except for blacklisting particular keys known to be problematic.

I suspect regexes might read more cleanly, but writing them is also more error-prone - if you can cleanly take mconnor's suggestion, it sounds good to me.
I'd stick to an array of regexes as in comment 28. The whitelist in that patch matches about half of the prefs I have in my profile, and I likely have a higher than average number of weirdo prefs, so I think iterating over a subset of the branches with XPCOM overhead doesn't really buy you much compared to a single "get all prefs" call followed by some filtering in pure-JS. That many regex compares isn't ideal either, but mconnor is right that the pref API isn't ideal for this any way you cut it. Maybe we can file a followup on exposing a more efficient method? I suppose it's may not be that common of a use case...
(In reply to comment #29)
> I'd stick to an array of regexes as in comment 28. ...

I think an array of regexes is the wrong way to go.  The current whitelist is 25 elements, and I think it's safe to assume that it's going to get longer rather than shorter.  In particular if we make an effort to replace wildcards with specific preferences (which I'd argue would better accomplish the whitelist's privacy aims) then we could be looking at hundreds of elements.  Then multiply that out by our 2k (3k?) of preferences, that's a lot of regex matching.

I'm trying out mconnor's approach right now to see how it measures up.  I suspect the XPCOM overhead isn't a real problem.
Created attachment 406378
preferences whitelist implementation, v2

This version is based on mconnor's proposed approach.  It treats the whitelist as a list of branches to traverse (fully-qualified individual prefs are a degenerate case), and accumulates all the prefs that match the whitelist.  This accumulated list is then filtered to select only modified, whitelisted prefs.

It would be faster to integrate the is-modified test with the whitelist traversal, but at the expense of (IMHO) making the code harder to understand.  I believe the code to already be more than fast enough -- we can rebuild the list of whitelisted prefs 100 times over in less than a second on my machine, so I think further optimization is unwarranted.

One deficiency of the new code is that if we get overlapping prefs in the whitelist, we may end up with duplicate entries in the table.  That won't cause any actual harm, and we shouldn't be putting overlapping things in the whitelist anyway.
Comment on attachment 406378
preferences whitelist implementation, v2

>+// We use a preferences whitelist to make sure we only show preferences that
>+// are useful for support and won't compromise the user's privacy.  Strings 
>+// in the whitelist array that end with a ".*" refer to an entire preference
>+// branch.  Other strings indicate specific individual preferences.  This list
>+// will no doubt evolve over time.
>+const Whitelist = [
>+  "accessibility.*",
>+  "browser.fixup.*",
>+  "browser.history.*",
>+  "browser.link.open_newwindow",

This mostly looks good, but we can actually do a lot simpler, here. Drop the asterisks. (And the code that parses/strips asterisks). getChildList is basically a stemming operation, so:

getChildList("accessibility.", {}) gives us an array of prefs starting with "accessibility.", and
getChildList("browser.zoom.updateBackgroundTabs", {}) gives us an array of 1 pref, the one named.

So we don't need asterisks or anything, just a list of strings to stem - the ones that are singletons will behave that way, the ones that are the roots of trees will behave that way.  Make sense?

>+function getWhitelistedPrefNames(prefService) {
>+  let results = [];
>+  let wildcardRegex = /[.][*]$/;
>+  let prefRootBranch = prefService.getBranch("");
>+  for each (let prefNameOrWildcard in Whitelist) {
>+    if (wildcardRegex.test(prefNameOrWildcard)) {
>+      // It's a wildcard.
>+      let prefix = prefNameOrWildcard.substring(0, prefNameOrWildcard.length - 1);

we can nix all the regexing and wildcard detecting here.

>+      let prefNames = prefRootBranch.getChildList(prefix, {value: 0 });

Do you need "value" here? Why not just {}?

>+      for each (let prefName in prefNames) {
>+        results.push(prefName); 
>+      }
>+    }
>+    else {
>+      // It's not a wildcard.
>+      results.push(prefNameOrWildcard);
>+    }

This can all be replaced with:

results.concat(prefNames)
Created attachment 406564
preferences whitelist implementation, v3

(In reply to comment #32)
> (From update of attachment 406378 [details])
> >+// We use a preferences whitelist to make sure we only show preferences that
> >+// are useful for support and won't compromise the user's privacy.  Strings 
> >+// in the whitelist array that end with a ".*" refer to an entire preference
> >+// branch.  Other strings indicate specific individual preferences.  This list
> >+// will no doubt evolve over time.
> >+const Whitelist = [
> >+  "accessibility.*",
> >+  "browser.fixup.*",
> >+  "browser.history.*",
> >+  "browser.link.open_newwindow",
> 
> This mostly looks good, but we can actually do a lot simpler, here. Drop the
> asterisks. (And the code that parses/strips asterisks). getChildList is
> basically a stemming operation, so:
> 
> getChildList("accessibility.", {}) gives us an array of prefs starting with
> "accessibility.", and
> getChildList("browser.zoom.updateBackgroundTabs", {}) gives us an array of 1
> pref, the one named.
> 
> So we don't need asterisks or anything, just a list of strings to stem - the
> ones that are singletons will behave that way, the ones that are the roots of
> trees will behave that way.  Make sense?


Done.


> >+function getWhitelistedPrefNames(prefService) {
> >+  let results = [];
> >+  let wildcardRegex = /[.][*]$/;
> >+  let prefRootBranch = prefService.getBranch("");
> >+  for each (let prefNameOrWildcard in Whitelist) {
> >+    if (wildcardRegex.test(prefNameOrWildcard)) {
> >+      // It's a wildcard.
> >+      let prefix = prefNameOrWildcard.substring(0, prefNameOrWildcard.length - 1);
> 
> we can nix all the regexing and wildcard detecting here.


Done.

One problem with treating the whitelist entries uniformly as prefixes is that one entry may be a prefix of another even though there's no branch relationship, for example:

  browser.startup.homepage
  
also matches

  browser.startup.homepage_override.mstone


> >+      let prefNames = prefRootBranch.getChildList(prefix, {value: 0 });
> 
> Do you need "value" here? Why not just {}?


Fixed.


> >+      for each (let prefName in prefNames) {
> >+        results.push(prefName); 
> >+      }
> >+    }
> >+    else {
> >+      // It's not a wildcard.
> >+      results.push(prefNameOrWildcard);
> >+    }
> 
> This can all be replaced with:
> 
> results.concat(prefNames)


Has to be

  results = results.concat(prefNames);

or, alternatively,

  Array.prototype.push.apply(results, prefNames);

I'm using the former in this patch.
you can discard browser.history. those prefs are old and unsopported.
I'm filing a bug to remove the remaining bits that i just found.

what you want instead is browser.history_expire_* not a nice choice for names, those should have been put in places.history_expire_* or browser.history.expire_
lazy developers! Due to that unfortunatly you will have to walk browser* or explicitly add
browser.history_expire_days
browser.history_expire_days_min
browser.history_expire_sites

could maybe be interesting to add browser.urlbar? Some user could have problems with the awesomebar due to changed behaviors or wrong set filters.

could network.proxy unveal some internal network informations?
Comment on attachment 406564
preferences whitelist implementation, v3

>diff -r b4949944d5e0 browser/base/content/aboutSupport.xhtml
>+  "browser.link.open_newwindow",
>+  "browser.link.open_newwindow.restriction",

Stemming of the former will implicitly include the latter, right? Do we need both?

>+  "browser.startup.homepage",
>+  "browser.startup.homepage_override.mstone",

Ditto. If we're keeping both here in order to be resilient against a future change in implementation style or something, we should comment that (and have a strategy for avoiding duplication), but I think we can probably just nix them? 

> window.onload = function () {
>   // Get the FUEL Application object.
>   let Application = Cc["@mozilla.org/fuel/application;1"]
>@@ -214,11 +246,21 @@
>   let prefService = Cc["@mozilla.org/preferences-service;1"]
>                       .getService(Ci.nsIPrefService);
>   let prefRootBranch = prefService.getBranch("");
>-  let prefNames = prefRootBranch.getChildList("", { value: 0 });
>+  let prefNames = getWhitelistedPrefNames(prefService);
>   let prefs = [Application.prefs.get(prefName)
>                       for each (prefName in prefNames)
>                           if (prefRootBranch.prefHasUserValue(prefName))];        
>   return prefs;
>+}
>+
>+function getWhitelistedPrefNames(prefService) {
>+  let results = [];
>+  let prefRootBranch = prefService.getBranch("");
>+  for each (let prefStem in Whitelist) {
>+    let prefNames = prefRootBranch.getChildList(prefStem, {});
>+    results = results.concat(prefNames);
>+  }
>+  return results;

I think the rest of this looks good, but:

 - Note Marco's comment about browser.history
 - I do think we should have a blacklist for post-processing as well. Just a simple list with the prefs-of-concern noted in the preceding comments (at least those that this new whitelist would still scrape up) - simple strings would probably work for now, if we need regex filtering later it can be a follow up bug. Then, instead of |return prefs| you can just do |return filterBlacklistedPrefNames(prefs)|.  Or just do a |return prefs.filter(...)| in place, really.

r- because I think we should have support for filtering, but I think we're basically done, here.
Created attachment 406877
preferences whitelist implementation, v4

(In reply to comment #35)
> (From update of attachment 406564 [details])
> >diff -r b4949944d5e0 browser/base/content/aboutSupport.xhtml
> >+  "browser.link.open_newwindow",
> >+  "browser.link.open_newwindow.restriction",
> 
> Stemming of the former will implicitly include the latter, right? Do we need
> both?


Removed "browser.link.open_newwindow.restriction".


> >+  "browser.startup.homepage",
> >+  "browser.startup.homepage_override.mstone",
> 
> Ditto. If we're keeping both here in order to be resilient against a future
> change in implementation style or something, we should comment that (and have a
> strategy for avoiding duplication), but I think we can probably just nix them? 


Removed "browser.startup.homepage_override.mstone".


> > window.onload = function () {
> >   // Get the FUEL Application object.
> >   let Application = Cc["@mozilla.org/fuel/application;1"]
> >@@ -214,11 +246,21 @@
> >   let prefService = Cc["@mozilla.org/preferences-service;1"]
> >                       .getService(Ci.nsIPrefService);
> >   let prefRootBranch = prefService.getBranch("");
> >-  let prefNames = prefRootBranch.getChildList("", { value: 0 });
> >+  let prefNames = getWhitelistedPrefNames(prefService);
> >   let prefs = [Application.prefs.get(prefName)
> >                       for each (prefName in prefNames)
> >                           if (prefRootBranch.prefHasUserValue(prefName))];        
> >   return prefs;
> >+}
> >+
> >+function getWhitelistedPrefNames(prefService) {
> >+  let results = [];
> >+  let prefRootBranch = prefService.getBranch("");
> >+  for each (let prefStem in Whitelist) {
> >+    let prefNames = prefRootBranch.getChildList(prefStem, {});
> >+    results = results.concat(prefNames);
> >+  }
> >+  return results;
> 
> I think the rest of this looks good, but:
> 
>  - Note Marco's comment about browser.history


Adjusted the whitelist accordingly.


>  - I do think we should have a blacklist for post-processing as well. Just a
> simple list with the prefs-of-concern noted in the preceding comments (at least
> those that this new whitelist would still scrape up) - simple strings would
> probably work for now, if we need regex filtering later it can be a follow up
> bug. Then, instead of |return prefs| you can just do |return
> filterBlacklistedPrefNames(prefs)|.  Or just do a |return prefs.filter(...)| in
> place, really.


Implemented a blacklist -- using regexes, since that was necessary to implement Reed's request for blacklisting "print.*.print_to_filename".


> r- because I think we should have support for filtering, but I think we're
> basically done, here.
Comment on attachment 406877
preferences whitelist implementation, v4

>diff -r b4949944d5e0 browser/base/content/aboutSupport.xhtml
>+// The blacklist, unlike the whitelist, is a list of regular expressions.
>+const Blacklist = [
>+  /^print[.]print_to_filename$/,
>+  /^print[.].*[.]print_to_filename$/,
>+  /^network[.]proxy[.].*$/
>+];

Out of curiosity, why do you escape here using the character range [] operators, instead of backslash? I haven't seen this before, and I suspect it might (*might*!) be slightly less performant, but it sure does make things easier to read in a case like this.

> function getModifiedPrefs() {
>   // We use the low-level prefs API to identify prefs that have been
>   // modified, rather that Application.prefs.all since the latter is
>   // much, much slower.  Application.prefs.all also gets slower each
>   // time it's called.  See bug 517312.
>   let prefService = Cc["@mozilla.org/preferences-service;1"]
>                       .getService(Ci.nsIPrefService);
>   let prefRootBranch = prefService.getBranch("");
>-  let prefNames = prefRootBranch.getChildList("", { value: 0 });
>+  let prefNames = getWhitelistedPrefNames(prefService);

Should have mentioned this sooner, but couldn't we just pass prefRootBranch in here, instead of prefService, thus eliminating the need to getBranch again in getWhitelistedPrefNames()? Or, if you prefer, turn prefService into gPrefService and make it a global, so that you don't really need to pass anything around.

r=me with that nit addressed one way or another. No need to request follow-up review.
(In reply to comment #37)
> (From update of attachment 406877 [details])
> >diff -r b4949944d5e0 browser/base/content/aboutSupport.xhtml
> >+// The blacklist, unlike the whitelist, is a list of regular expressions.
> >+const Blacklist = [
> >+  /^print[.]print_to_filename$/,
> >+  /^print[.].*[.]print_to_filename$/,
> >+  /^network[.]proxy[.].*$/
> >+];
> 
> Out of curiosity, why do you escape here using the character range []
> operators, instead of backslash? I haven't seen this before, and I suspect it
> might (*might*!) be slightly less performant, but it sure does make things
> easier to read in a case like this.


** but it sure does make things easier to read in a case like this.**

Answered your own question, I think :-).  I've never looked into the performance, and I should do that.  I suspect character classes with small numbers of classes have been specifically optimized in most regex engines, but it's probably a good thing to check.  If there's a perf hit, most likely it's at compile time, and there could be a memory usage hit.  On the other hand, it's probably unlikely that unicode-savvy regex engines are allocating 64K tables every time they hit a character class.


> 
> > function getModifiedPrefs() {
> >   // We use the low-level prefs API to identify prefs that have been
> >   // modified, rather that Application.prefs.all since the latter is
> >   // much, much slower.  Application.prefs.all also gets slower each
> >   // time it's called.  See bug 517312.
> >   let prefService = Cc["@mozilla.org/preferences-service;1"]
> >                       .getService(Ci.nsIPrefService);
> >   let prefRootBranch = prefService.getBranch("");
> >-  let prefNames = prefRootBranch.getChildList("", { value: 0 });
> >+  let prefNames = getWhitelistedPrefNames(prefService);
> 
> Should have mentioned this sooner, but couldn't we just pass prefRootBranch in
> here, instead of prefService, thus eliminating the need to getBranch again in
> getWhitelistedPrefNames()? Or, if you prefer, turn prefService into
> gPrefService and make it a global, so that you don't really need to pass
> anything around.


I'll have a new patch shortly.

 
> r=me with that nit addressed one way or another. No need to request follow-up
> review.
Created attachment 407106
preferences whitelist implementation, v5

Identical to v4, except that "prefRootBranch" is passed to getWhitelistedPrefNames(), rather than "prefService".
http://hg.mozilla.org/mozilla-central/rev/5240d11beb4b
Comment on attachment 407106
preferences whitelist implementation, v5

>diff -r b4949944d5e0 browser/base/content/aboutSupport.xhtml
>+const Whitelist = [
>+  "accessibility.",
>+  "browser.fixup.",
...
>+];

>+function getWhitelistedPrefNames(prefRootBranch) {
>+  let results = [];
>+  for each (let prefStem in Whitelist) {
>+    let prefNames = prefRootBranch.getChildList(prefStem, {});
>+    results = results.concat(prefNames);
>+  }
>+  return results;
>+}
Don't use "for each" on arrays.
See bug 521216 comment 2.
(In reply to comment #41)
> (From update of attachment 407106 [details])
> >diff -r b4949944d5e0 browser/base/content/aboutSupport.xhtml
> >+const Whitelist = [
> >+  "accessibility.",
> >+  "browser.fixup.",
> ...
> >+];
> 
> >+function getWhitelistedPrefNames(prefRootBranch) {
> >+  let results = [];
> >+  for each (let prefStem in Whitelist) {
> >+    let prefNames = prefRootBranch.getChildList(prefStem, {});
> >+    results = results.concat(prefNames);
> >+  }
> >+  return results;
> >+}
> Don't use "for each" on arrays.
> See bug 521216 comment 2.

filed bug 523312
(In reply to comment #41)
> (From update of attachment 407106 [details])
> >diff -r b4949944d5e0 browser/base/content/aboutSupport.xhtml
> >+const Whitelist = [
> >+  "accessibility.",
> >+  "browser.fixup.",
> ...
> >+];
> 
> >+function getWhitelistedPrefNames(prefRootBranch) {
> >+  let results = [];
> >+  for each (let prefStem in Whitelist) {
> >+    let prefNames = prefRootBranch.getChildList(prefStem, {});
> >+    results = results.concat(prefNames);
> >+  }
> >+  return results;
> >+}
> Don't use "for each" on arrays.
> See bug 521216 comment 2.

In this case I don't think it matters much - there are no user-defined properties on this array, and we don't care about ordering. Still, though, you're right - I'm sorry I didn't flag this earlier.
(In reply to comment #43)
> (In reply to comment #41)
> > (From update of attachment 407106 [details] [details])
> > >diff -r b4949944d5e0 browser/base/content/aboutSupport.xhtml
> > >+const Whitelist = [
> > >+  "accessibility.",
> > >+  "browser.fixup.",
> > ...
> > >+];
> > 
> > >+function getWhitelistedPrefNames(prefRootBranch) {
> > >+  let results = [];
> > >+  for each (let prefStem in Whitelist) {
> > >+    let prefNames = prefRootBranch.getChildList(prefStem, {});
> > >+    results = results.concat(prefNames);
> > >+  }
> > >+  return results;
> > >+}
> > Don't use "for each" on arrays.
> > See bug 521216 comment 2.
> 
> In this case I don't think it matters much - there are no user-defined
> properties on this array, and we don't care about ordering. Still, though,
> you're right - I'm sorry I didn't flag this earlier.

Are you guys freaking kidding me?  I thought the whole point of "for each" was that it would work on arrays.  Am I correct in assuming that "for each" is broken inside of array comprehensions as well?
Yes, but it's still expected to be used inside of array comprehensions. It's schizophrenic.
(In reply to comment #45)
> Yes, but it's still expected to be used inside of array comprehensions. It's
> schizophrenic.

The presence of user properties in Array.prototype will break "for each" inside of array comprehensions as well.

In general:

The docs at 

  https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Statements/for_each...in

say:

  Warning: Never use a loop like this on arrays. Only use it on objects.
  
In explanation it then links to

  https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Statements/for...in#Description
  
which says:

  Although it may be tempting to use this as a way to iterate over an Array, this is a bad idea. The for...in statement iterates over user-defined properties in addition to the array elements, so if you modify the array's non-integer or non-positive properties (e.g. by adding a "foo" property to it or even by adding a method or property to Array.prototype), the for...in statement will return the name of your user-defined properties in addition to the numeric indexes. Also, because order of iteration is arbitrary, iterating over an array may not visit elements in numeric order. Thus it is better to use a traditional for  loop with a numeric index when iterating over arrays. Similar arguments might be used against even using for...in at all (at least without propertyIsEnumerable() or hasOwnProperty() checks), since it will also iterate over Object.prototype (which, though usually discouraged, can, as in the case of Array.prototype, be usefully extended by the user where are no namespacing concerns caused by inclusion of other libraries which might not perform the above checks on such iterations and where they are aware of the effect such extension will have on their own use of iterators such as for...in).

This lists two problems with using for ... in for iterating arrays:
1. User-defined properties (instance or prototype) will also be enumerated.
2. Order of enumeration is arbitrary

So I've got some questions here:

Is #1 sufficient reason not to use for each...in even when we know we are using know Array objects and when we know that no user-defined properties have been added either to the Array instances or to Array.prototype?

Is #2 still true in the latest version of JavaScript?  I haven't been following the JavaScript/ECMAScript standards as closely as perhaps I should.  However, I'm under the impression that the latest standard strictly defines the iteration order for for...in.  Am I wrong about that?

If we should not be using for each...in for iterating arrays in general, should we also never use it for iterating arrays inside array comprehensions?  At the very least it looks like for each...in is still subject to the iterating user properties problem even inside an array comprehension.  I can only conclude that it would be equally subject to arbitrary iteration order, if that is indeed a problem.

How many other places in the code are we for each...in in the codebase?  I note that the first two occurrences of "for each" in browser.js are blatant uses of "for each" to iterate over arrays.
(In reply to comment #46)
> Is #1 sufficient reason not to use for each...in even when we know we are using
> know Array objects and when we know that no user-defined properties have been
> added either to the Array instances or to Array.prototype?

Whenever you want the elements, using a method that does just that makes your code more robust. Whether you do or do not expect user-defined properties isn't a useful question to ask every time you iterate over an array.
Also note that MDC isn't quite correct about built-in methods when it comes to non-native-JS objects. For instance, for...in iterates over "length" and "item" in node lists. Using Array.forEach consistently avoids this problem.

> Is #2 still true in the latest version of JavaScript?  I haven't been following
> the JavaScript/ECMAScript standards as closely as perhaps I should.  However,
> I'm under the impression that the latest standard strictly defines the
> iteration order for for...in.  Am I wrong about that?

I don't know. Where did you find it?

> If we should not be using for each...in for iterating arrays in general, should
> we also never use it for iterating arrays inside array comprehensions?  At the
> very least it looks like for each...in is still subject to the iterating user
> properties problem even inside an array comprehension.  I can only conclude
> that it would be equally subject to arbitrary iteration order, if that is
> indeed a problem.

It may cause problems, but it won't necessarily cause a problem in every single case. In general I think we should avoid it, but there's no strong need to replace every single instance in code that has been working reliably for months and years.

> How many other places in the code are we for each...in in the codebase?  I note
> that the first two occurrences of "for each" in browser.js are blatant uses of
> "for each" to iterate over arrays.

That's not a reason to introduce new instances.
Created attachment 407566
[patch for 1.9.2] preferences whitelist implementation, v5

This patch applies cleanly on branch as of a few minutes ago.
(In reply to comment #48)
> Created an attachment (id=407566) [details]
> [patch for 1.9.2] preferences whitelist implementation, v5
> 
> This patch applies cleanly on branch as of a few minutes ago.

Can we get a patch for 1.9.2 that includes what was committed in bug 523312? Note that what was committed doesn't match what the patch in that bug has.
(In reply to comment #49)
> (In reply to comment #48)
> > Created an attachment (id=407566) [details] [details]
> > [patch for 1.9.2] preferences whitelist implementation, v5
> > 
> > This patch applies cleanly on branch as of a few minutes ago.
> 
> Can we get a patch for 1.9.2 that includes what was committed in bug 523312?
> Note that what was committed doesn't match what the patch in that bug has.

I'm not sure I can parse your last sentence there.

Anyway, I considered incorporating those changes and decided not to, since bug 523312 doesn't have branch approval yet.  The changes between the two v5 patches here are just whitespace which I figure is OK.
Created attachment 407580
combined v5 + bug 523312 (for 1.9.2 branch)

In the long run, it's easier on drivers and the person committing the patches to just combine things together as they go from trunk to a branch. Otherwise, things get forgotten.
I just committed http://hg.mozilla.org/mozilla-central/rev/1afef31990f3 to fix the whitespacing mess between trunk and 1.9.2 branch. No more need for separate patches just because of whitespace.
Created attachment 407628
combined v5 + bug 523312 (for 1.9.2 branch)

v5 actually applies on 1.9.2 now, but reed says we should land bug 523312 there too to avoid future conflicts. So here it is.
Comment on attachment 407628
combined v5 + bug 523312 (for 1.9.2 branch)

Let's get this landed on 1.9.2 - afaik, there hasn't been any fallout from this baking on trunk (whitespace issues aside)?
http://hg.mozilla.org/releases/mozilla-1.9.2/rev/2dea0687c88a

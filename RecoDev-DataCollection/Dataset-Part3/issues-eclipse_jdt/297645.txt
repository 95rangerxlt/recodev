User-Agent:       Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/3.0.195.33 Safari/532.0
Build Identifier: M20090917-0800

Since the introduction of auto-boxing/auto-unboxing it has become legal to use expressions of type java.lang.Boolean for 'if' statement expressions.  Eclipse's "quick fix" should be updated accordingly.

I think the problem is near line 474 or 551 of org/eclipse/jdt/internal/ui/text/correction/AdvancedQuickAssistProcessor.java

Here are a few relevant stack frames I got while debugging the problem: 

AdvancedQuickAssistProcessor.isBoolean(Expression) line: 551	
AdvancedQuickAssistProcessor.getInversedBooleanExpression(ASTRewrite, Expression, AdvancedQuickAssistProcessor$SimpleNameRenameProvider) line: 474	
AdvancedQuickAssistProcessor.getInversedBooleanExpression(ASTRewrite, Expression) line: 454	
AdvancedQuickAssistProcessor.getInverseIfProposals(IInvocationContext, ASTNode, Collection) line: 268	
AdvancedQuickAssistProcessor.getAssists(IInvocationContext, IProblemLocation[]) line: 142

Reproducible: Always

Steps to Reproduce:
1. enter some java code containing an 'if' statement with a Boolean expression.  For example:
@SuppressWarnings("boxing") // may be needed to help ctrl+1 work
public void foo(Boolean b) {
	if (b) {
		System.out.println("######");
	} else {
		System.out.println("-");
	}
}

2. Invoke "Quick Fix" (ctrl+1) and choose "Invert 'If' statement".  The statement should now look like "if (!b) ..." but eclipse produces "if (b) ..."

User-Agent:       Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/3.0.195.33 Safari/532.0
Build Identifier: M20090917-0800

Since the introduction of auto-boxing/auto-unboxing it has become legal to use expressions of type java.lang.Boolean for 'if' statement expressions.  Eclipse's "quick fix" should be updated accordingly.

I think the problem is near line 474 or 551 of org/eclipse/jdt/internal/ui/text/correction/AdvancedQuickAssistProcessor.java

Here are a few relevant stack frames I got while debugging the problem: 

AdvancedQuickAssistProcessor.isBoolean(Expression) line: 551	
AdvancedQuickAssistProcessor.getInversedBooleanExpression(ASTRewrite, Expression, AdvancedQuickAssistProcessor$SimpleNameRenameProvider) line: 474	
AdvancedQuickAssistProcessor.getInversedBooleanExpression(ASTRewrite, Expression) line: 454	
AdvancedQuickAssistProcessor.getInverseIfProposals(IInvocationContext, ASTNode, Collection) line: 268	
AdvancedQuickAssistProcessor.getAssists(IInvocationContext, IProblemLocation[]) line: 142

Reproducible: Always

Steps to Reproduce:
1. enter some java code containing an 'if' statement with a Boolean expression.  For example:
@SuppressWarnings("boxing") // may be needed to help ctrl+1 work
public void foo(Boolean b) {
	if (b) {
		System.out.println("######");
	} else {
		System.out.println("-");
	}
}

2. Invoke "Quick Fix" (ctrl+1) and choose "Invert 'If' statement".  The statement should now look like "if (!b) ..." but eclipse produces "if (b) ..."
Created attachment 154352
Proposed patch to fix bug

Patch for 
org/eclipse/jdt/internal/ui/text/correction/AdvancedQuickAssistProcessor.java
of
org.eclipse.jdt.ui.source_3.5.1.r351_v20090821-0800.jar


This seems to work OK to fix the bug I described.  I would have preferred to make the change in the method isBoolean(), but since this is used in two other places (e.g. invert local variables), I was not sure whether that would be reasonable. 


On a slightly different note - I think it makes sense to always apply the '!' operator when the predicate expression is of the wrong type.
The following example should make this clear:
if
(x.getClass().isAnotation()) {
	System.out.println("######");
} else {
	System.out.println("-");
}
There is a compilation error because the method isAnnotation() is spelled incorrectly.  The "Invert 'if' statement" quick fix is available, but it does not add the '!' operator.  I think the quick fix should make the most consistent change it can regardless of compilation errors.
Move to JDT/UI
> I would have preferred to
> make the change in the method isBoolean(), but since this is used in two other
> places (e.g. invert local variables), I was not sure whether that would be
> reasonable. 

getInversedBooleanExpression(..) also has more than 1 caller, so the change is not local and we have to consider additional effects anyway.

> On a slightly different note - I think it makes sense to always apply the '!'
> operator when the predicate expression is of the wrong type.

I've fixed that as well and removed the 'Boolean' from some method names. This revealed another issue in getInversedInfixBooleanExpression(..) (which unnecessarily inverted the operands of == and != expressions), so I've fixed that as well.

Released to HEAD and added tests.

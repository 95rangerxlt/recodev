BETA_JAVA8:

We need to add support for exposing and manipulating 

    - Annotations on type references including wildcards,
    - Annotations on type parameters,
    - Annotations on receivers of methods and inner class constructors,
    - Annotations on varargs ... parameter,
    - Annotations on array creation expressions

in the DOM/AST API.

BETA_JAVA8:

We need to add support for exposing and manipulating 

    - Annotations on type references including wildcards,
    - Annotations on type parameters,
    - Annotations on receivers of methods and inner class constructors,
    - Annotations on varargs ... parameter,
    - Annotations on array creation expressions

in the DOM/AST API.
Created attachment 222260
Work in progress - patch v0.1
Created attachment 222261
Work in progress - patch v0.2
Olivier & Markus,

Two questions:

(1) DOM MethodDeclaration declares thrown exceptions to be of element type Name
and NOT Type.

	/**
	 * The "thrownExceptions" structural property of this node type (element type: {@link Name}).
	 * @since 3.0
	 */
	public static final ChildListPropertyDescriptor THROWN_EXCEPTIONS_PROPERTY =
		new ChildListPropertyDescriptor(MethodDeclaration.class, "thrownExceptions", Name.class, NO_CYCLE_RISK); //$NON-NLS-1$

while tracing the chain on the CatchClause side we encounter a Type.

I need to make the former a Type to be able to attach 308 annotations. (don't
want to add it Name node also).

Is it correct that no client can have dependencies on the element type directly
and has to go by what the ChildListPropertyDescriptor claims and this itself
is subject to change ? 

OIOW, does this change constitute an API breakage ?

	public static final ChildListPropertyDescriptor THROWN_EXCEPTIONS_PROPERTY =
		new ChildListPropertyDescriptor(MethodDeclaration.class, "thrownExceptions", Type.class, NO_CYCLE_RISK); 

(2) Likewise 
org.eclipse.jdt.core.dom.ASTConverter.convert(TypeReference)

returns a Name and not a Type. Looking at the call sites of this
method, there are only two worrisome cases from JLS8 point of view,
one of which is already covered by (1) above. The other is the call
originating from the tail end of org.eclipse.jdt.core.dom.ASTConverter.convert(Expression) via:

	if (expression instanceof org.eclipse.jdt.internal.compiler.ast.TypeReference) {
			return convert((org.eclipse.jdt.internal.compiler.ast.TypeReference) expression);
		}

I am not sure this call can ever be reached - I think it is simply
there because of type hierarchy differences between compiler AST 
and DOM/AST (in the former TypeReference is a subtype of Expression
while not so in the latter.)
(In reply to comment #3)
> Olivier & Markus,
> 
> Two questions:

Three actually:

When given a QualifiedTypeReference to convert, org.eclipse.jdt.core.dom.ASTConverter.convertType(TypeReference) actually
creates a SimpleType with a QualifiedName

Why ??
Stephan, you are welcome to chime in too.
Created attachment 222264
Work in progress - patch v0.3

AST converter work is stalled somewhat until issues (1) - (3) listed
earlier are understood.
(In reply to comment #4)
> (In reply to comment #3)
> > Olivier & Markus,
> > 
> > Two questions:
> 
> Three actually:
> 
> When given a QualifiedTypeReference to convert,
> org.eclipse.jdt.core.dom.ASTConverter.convertType(TypeReference) actually
> creates a SimpleType with a QualifiedName
> 
> Why ??

Does the class javadoc of QualifiedType answer this?

"... A type like "A.B" can be represented either of two ways:
  QualifiedType(SimpleType(SimpleName("A")),SimpleName("B"))
  SimpleType(QualifiedName(SimpleName("A"),SimpleName("B")))
 The first form is preferred when "A" is known to be a type. However, a parser
 cannot always determine this. Clients should be prepared to handle either
 rather than make assumptions. (Note also that the first form became possible
 as of JLS3; only the second form existed in JLS2 API.).."

Does this qualify as: "for historical reasons"?
(In reply to comment #3)
> 	/**
> 	 * The "thrownExceptions" structural property of this node type (element
> type: {@link Name}).
> 	 * @since 3.0
> 	 */
> 	public static final ChildListPropertyDescriptor THROWN_EXCEPTIONS_PROPERTY =
> 		new ChildListPropertyDescriptor(MethodDeclaration.class,
> "thrownExceptions", Name.class, NO_CYCLE_RISK); //$NON-NLS-1$
> 
> while tracing the chain on the CatchClause side we encounter a Type.
> 
> I need to make the former a Type to be able to attach 308 annotations. (don't
> want to add it Name node also).
> 
> Is it correct that no client can have dependencies on the element type
> directly
> and has to go by what the ChildListPropertyDescriptor claims and this itself
> is subject to change ? 

Javadoc clearly mentions "Name", so I'd say that's API.
 
See also:
  /**
   * Returns the live ordered list of thrown exception names in this method
   * declaration.
   *
   * @return the live list of exception names
   *    (element type: {@link Name})
   */
  public List thrownExceptions()

Aren't we adding a new JLS level for Java8 DOM anyway?
At that level we might need a THROWN_EXCEPTIONS2_PROPERTY,
at least that's what prior art regarding MODIFIERS2 seems to suggest, no?
(In reply to comment #7)
> (In reply to comment #4)
> > (In reply to comment #3)
> > > Olivier & Markus,
> > > 
> > > Two questions:
> > 
> > Three actually:
> > 
> > When given a QualifiedTypeReference to convert,
> > org.eclipse.jdt.core.dom.ASTConverter.convertType(TypeReference) actually
> > creates a SimpleType with a QualifiedName
> > 
> > Why ??
> 
> Does the class javadoc of QualifiedType answer this?

I would say the javadoc explains why things work and not why they should be
the way they are.

>  The first form is preferred when "A" is known to be a type. However, a
> parser
>  cannot always determine this.

The two cases I cite, the parser clearly knows them to be TypeReferences.

That said, the part about "Clients should be prepared to handle either
 rather than make assumptions." unblocks my work at the moment,
(In reply to comment #8)

> Javadoc clearly mentions "Name", so I'd say that's API.

Good point.

> Aren't we adding a new JLS level for Java8 DOM anyway?
> At that level we might need a THROWN_EXCEPTIONS2_PROPERTY,
> at least that's what prior art regarding MODIFIERS2 seems to suggest, no?

Good suggestion, again this unblocks me at the moment. Thanks Stephan!

Olivier & Markus, would still to love to hear the reasons why things were
originally coded the way they are.
(In reply to comment #7)

>  The first form is preferred when "A" is known to be a type. However, a
> parser
>  cannot always determine this.

I am not sure if this is true anymore of our implementation or even of Java
in general (after the resolution of https://bugs.eclipse.org/bugs/show_bug.cgi?id=292364).

There is still the static message send case documented in the Javadoc of
NameReference - but JSR308 EDR argues that these are not types in the
first place: "JSR 308 does not support annotations on type names that syntactically look like, but are not, type uses.", "The type name in front 
of a static member access is a scoping mechanism, not a use of a type"

I don't know of other cases. At this point, this is academic concern only
and not blocking the current work.
(In reply to comment #11)

> I don't know of other cases. 

Of course, with Java8 we have the reference expressions name and type forms
which could look the same to the parser.
(In reply to comment #4)
> (In reply to comment #3)
> > Olivier & Markus,
> > 
> > Two questions:
> 
> Three actually:

Four actually:

(4) The prevalent practice when it comes to optional properties seems to
be to initialize the ASTNode field with an empty list: As in the type
parameters property.

MethodDeclaration(AST ast) {
		super(ast);
		if (ast.apiLevel >= AST.JLS3_INTERNAL) {
			this.typeParameters = new ASTNode.NodeList(TYPE_PARAMETERS_PROPERTY);
		}
	}

With type annotations, I am actually returning null instead of an empty
list and this is documented in the child list accessor/retriever method.
Is there an overwhelming/overriding concern that argues for sticking to
the empty list approach ?

This calls for the AST building code in ASTConvertor to first create with
an empty list and then start populating children. With Type nodes ubiquitous
I thought this would save memory.

Any concerns ?
(In reply to comment #13)
> With type annotations, I am actually returning null instead of an empty
> list ...

This conflicts with typical use for AST rewriting, where clients fetch the
existing (possibly empty) list and then add new elements to the list
(using perhaps a list rewriter or by direct manipulation).

How would these clients be coded if the list is null?
(In reply to comment #14)
> (In reply to comment #13)
> > With type annotations, I am actually returning null instead of an empty
> > list ...
> 
> This conflicts with typical use for AST rewriting, where clients fetch the
> existing (possibly empty) list and then add new elements to the list
> (using perhaps a list rewriter or by direct manipulation).
> How would these clients be coded if the list is null?

I agree it is a departure from the overall style of doing things. Part of the
motivation to raise this issue was to understand if there are clients outside
of our code base that would be surprised by/burdened by this.

I see four ways of handling this:

(1) In ASTConverter, I am using this code pattern: (where typeReference is
compiler node and wildcardType is a freshly created DOM node)

if (typeReference.annotations != null) {
				wildcardType.annotations = wildcardType.new NodeList(WildcardType.ANNOTATIONS_PROPERTY);
				annotateType(wildcardType, typeReference.annotations[0]);
			}

Now this *may be* acceptable if all clients are in our control.

(2) Alternately we can introduce a new API on Type node to add an annotation
which would do the "right thing".

(3) Yet another approach is to create Additional subtypes in the Type
hierarchy: a la AnnotatedPrimitiveType, AnnotatedSimpleType etc and
manufacture one or the other based on presence or absence of annotations.

(4) Ignore the whole issue and follow present style and create an empty
list.

(1), (2) and (3) represent departures from the present scheme of things
and manage memory better at the expense of slightly more coding complexity.

Question: Is my concern around additional memory footprint justified ?
(a) we are going to be creating empty lists all over the place given how
ubiquitous Type nodes are - (b) I am also have the view that JSR308 style
annotations are going to find very limited adoption.
(In reply to comment #15)

> Question: Is my concern around additional memory footprint justified ?
> (a) we are going to be creating empty lists all over the place given how
> ubiquitous Type nodes are - 

It is also my understanding that once a new JLS level is published, JDT/UI
starts using it for all source levels. So this code pattern prevalent
in DOM/AST code:

	ClassInstanceCreation (AST ast) {
		super(ast);
		if (ast.apiLevel >= AST.JLS3_INTERNAL) {
			this.typeArguments = new ASTNode.NodeList(TYPE_ARGUMENTS_PROPERTY);
		}
	}
is not particularly effective in reducing memory usage.
Looking at the size and scope of this effort, it is better managed as
several unit tasks that can be worked in parallel by different engineers.
So I propose to use the current bug as the umbrella bug for DOM/AST work 
for JSR308 and spawn several additional blocker bugs.

Each new bug will cover complete work for specific node types/concerns.
(1) The declared types of ASTNode properties and the element types of property descriptors and lists are APIs that must stay stable for AST levels <= JLS4. We consider API contracts in prose equally binding as if the API used generics to specify the types of elements.

TypeDeclaration#SUPER_INTERFACES_PROPERTY and #superInterfaces() show how to phase out a List<Name> and replace it with a List<Type>.

(In reply to comment #13)
The API for an optional list-valued property must not return null. That would be a very confusing deviation from how stuff worked up to now. It would also be confusing that ASTNode#getStructuralProperty(..) returns an empty list, but a direct invocation of the property method returns null. The structural properties API should be equivalent to the direct API.

I don't think we should use a new strategy without hard evidence that proves that this is really a huge problem in practice and that avoiding empty lists would solve more problems than other approaches to reduce footprint (e.g. bug 150657).

The best you could do is to create the NodeList and/or NodeList#store lazily.
(In reply to comment #15)
> Additional subtypes in the Type hierarchy: a la AnnotatedPrimitiveType,
> AnnotatedSimpleType etc [..]

That's an interesting direction. Could we just leave Type alone but add an AnnotatedType that extends Type and has annotations and a wrapped Type as children?

Then all ASTs with source level <= 1.7 would stay exactly the same, and we wouldn't have any overhead for the annotations. That would also solve the problem in patch v0.3 that it doesn't make sense to declare annotations on a UnionType.

The AnnotatedType would increase the node count in heavily annotated code, but I agree this will (or at least should) not be the normal case.
(In reply to comment #19)
> (In reply to comment #15)
> > Additional subtypes in the Type hierarchy: a la AnnotatedPrimitiveType,
> > AnnotatedSimpleType etc [..]
> 
> That's an interesting direction. Could we just leave Type alone but add an
> AnnotatedType that extends Type and has annotations and a wrapped Type as
> children?

Sure, I think this can dramatically cut down the volume of changes and number
classes affected while also addressing the worry around empty lists. Thanks!
(In reply to comment #20)
> (In reply to comment #19)
> > (In reply to comment #15)
> > > Additional subtypes in the Type hierarchy: a la AnnotatedPrimitiveType,
> > > AnnotatedSimpleType etc [..]
> > 
> > That's an interesting direction. Could we just leave Type alone but add an
> > AnnotatedType that extends Type and has annotations and a wrapped Type as
> > children?
> 
> Sure, I think this can dramatically cut down the volume of changes and number
> classes affected while also addressing the worry around empty lists. Thanks!

Complications, Complications.

While this approach is elegant, it is frought with problems:

(1) There are some APIs that encode specific types - for example a search 
for references of ArrayType  shows org.eclipse.jdt.core.dom.ArrayCreation.setType(ArrayType) directly
encoding ArrayType. I cannot pass an AnnotatedType that is a direct 
subtype of Type, there has to be an AnnotatedArrayType.

(2) What should AnnotatedType.isQualifiedType, isParameterizedType() etc
should answer ? If they delegate to the wrapped type and let the wrapped
type answer it, then various casts would start blowing up:

if (this.currentType.isParameterizedType()) {
			ParameterizedType parameterizedType = (ParameterizedType) this.currentType;

etc.

I see only two ways out:

(A) take the ostrich approach, continue with WIP patch#3 which adds
annotations property to existing nodes, but make sure they return
empty lists and not null.

(B) Invent an Annotated* variant of every type node.

I am leaning towards (A) now.

Any strong concerns ?
(In reply to comment #7)

> > When given a QualifiedTypeReference to convert,
> > org.eclipse.jdt.core.dom.ASTConverter.convertType(TypeReference) actually
> > creates a SimpleType with a QualifiedName
> > 
> > Why ??

Also I plan to get rid of this bogus (well not may be bogus, but a documentedly
quircky) subtree and uniformly at all JLS levels construct a QualifiedType 
when handed a  QualifiedTypeReference. Per javadoc Stephan cited clients should 
be prepared for both forms - 

"... A type like "A.B" can be represented either of two ways:
  QualifiedType(SimpleType(SimpleName("A")),SimpleName("B"))
  SimpleType(QualifiedName(SimpleName("A"),SimpleName("B")))
The first form is preferred when "A" is known to be a type..."

This last part hasn't been true of our implementation and I am proposing
to make it true so we can just live with one implementation.

Any concerns/objections ?
(In reply to comment #21)
> I see only two ways out:
> 
> (A) take the ostrich approach, continue with WIP patch#3 which adds
> annotations property to existing nodes, but make sure they return
> empty lists and not null.
> 
> (B) Invent an Annotated* variant of every type node.
> 
> I am leaning towards (A) now.
> 
> Any strong concerns ?

Are you saying we have to trade between runtime penalties (A) and code bloat (B)?

As for (B) which disadvantage is prevailing in your judgement? Number of classes? Duplication of the code managing the list of type annotations? Would the duplication of classes affect other parts of the code, too?
I'm asking because my feeling is that (B) isn't "bad" it's just not "elegant".

As for code duplication, I guess the common parts could perhaps be placed into Type as dormant code, dormant unless explicitly enabled by a sub-class.


On a separate note: wrt sharing empty lists, I think a constant, shared, unmodifiable list could solve much of this. 
Describing flavor of rewriting (using ListRewriter) could perhaps detect the empty list and through special API have it automatically replaced with a new modifiable list. Only for modifying rewrite this doesn't work.

But maybe we can require future clients wishing to rewrite this list using direct AST modification to first call a new API like .ensureModifiableAnnotationList()?

Are there other scenarios that would break when the list of annotations is not modifiable (because shared empty list)?
(In reply to comment #23)

> Are you saying we have to trade between runtime penalties (A) and code bloat
> (B)?

Yes, runtime space penalty of unknown seriousness at this point and code
clutter.

> As for (B) which disadvantage is prevailing in your judgement? Number of
> classes? Duplication of the code managing the list of type annotations?
> Would the duplication of classes affect other parts of the code, too?
> I'm asking because my feeling is that (B) isn't "bad" it's just not
> "elegant".

Personally I don't even view (B) as being inelegant, but the basic concern
is about departing from prevailing architecture/practice to ameliorate something
that is not known to be an issue on the one hand (As Markus alluded to
the real bang for the buck in memory utilization improvement could be
elsewhere altogether,) and getting bogged down in benchmarking on the other.
 
> On a separate note: wrt sharing empty lists, I think a constant, shared,
> unmodifiable list could solve much of this. 
> Describing flavor of rewriting (using ListRewriter) could perhaps detect the
> empty list and through special API have it automatically replaced with a new
> modifiable list. Only for modifying rewrite this doesn't work.
> 
> But maybe we can require future clients wishing to rewrite this list using
> direct AST modification to first call a new API like
> .ensureModifiableAnnotationList()?
> 
> Are there other scenarios that would break when the list of annotations is
> not modifiable (because shared empty list)?

Don't know. If memory wastage is real, then inventing new classes should be
an easier solution on clients.
(In reply to comment #24)

> elsewhere altogether,) and getting bogged down in benchmarking on the other.

For the heck of it, I threw in some crude benchmarking va counting: On a 
slightly dated Parser.java file (11K lines long, no generics at all), we
seem to create 2778 empty lists. However it must be pointed out that at
this point, 

   - because of the way we handle Qualified Type References as mentioned in
earlier comments we are not counting many lists. (In the prototype WIP patch
Name nodes do not have annotations property)
   - Various AST nodes such ArrayCreation etc are not handling annotations
yet and so are missing in the count.
   - Annotations on extended dimensions are not counted.

    I think if we settle for a gross approximation of 1 empty list/LOC,
is that something we say is part of doing business and move on or do we want
to sign up for a solution right away ?
(In reply to comment #21)
I agree we should go route (A), i.e. add Type#annotations().

I see that the AnnotatedType would cause similar trouble in client code (losing static type safety because every type could be wrapped, more work in scenarios where the annotations are irrelevant).

The Annotated* variant would be equivalent to Type#annotations() -- it would just need an additional cast before the annotations can be accessed.

(In reply to comment #22)
> "... A type like "A.B" can be represented either of two ways:
>   QualifiedType(SimpleType(SimpleName("A")),SimpleName("B"))
>   SimpleType(QualifiedName(SimpleName("A"),SimpleName("B")))
> The first form is preferred when "A" is known to be a type..."
> 
> This last part hasn't been true of our implementation and I am proposing
> to make it true so we can just live with one implementation.

I agree you're allowed to do that. However, I quickly looked at usages of SimpleType#getName() in JDT UI code, and I think we (illegally) rely on the current form in most of our code. So expect a lot of UI test failures when you touch this. I know our code shouldn't care about the form, but in practice, it does, because it has never been challenged.
=> If it really cleans up your code, then go for it. Otherwise, I'd prefer to keep the current form for compatibility (especially for ASTs <= JLS4).

(In reply to comment #25)
The additional memory consumption is acceptable. If we wanted to change the handling of node lists, then we should do it in the whole AST API, e.g. via a flag on ASTParser to request an unmodifiable AST (sets the ASTNode.PROTECT flag and can share an empty NodeList).
(In reply to comment #26)
> (In reply to comment #21)
> I agree we should go route (A), i.e. add Type#annotations().

> The Annotated* variant would be equivalent to Type#annotations() -- it would
> just need an additional cast before the annotations can be accessed.

Just to be sure: The last part is just an academic point - right ? (A)
simply follows the present practice of returning empty lists and does not
involve creation of Annotated* variants.

> (In reply to comment #22)

> I agree you're allowed to do that. However, I quickly looked at usages of
> SimpleType#getName() in JDT UI code, and I think we (illegally) rely on the
> current form in most of our code. So expect a lot of UI test failures when
> you touch this. 

We can certainly tread the middle path to avoid the pain in the UI 
component, but a question: if we consistently return a QualifiedType for 
JLS8+ whether or not there are annotations AND continue to do what we do 
today for JLS4-, wouldn't all of your codebase anyway have to change ?
The only way I see it wouldn't have to change is if we continue to do
exactly what we do today even at JLS8+ - that requires adding annotations
to Name nodes, some thing I am not very excited about, but can do if
needed.

> (In reply to comment #25)
> The additional memory consumption is acceptable. 

Great, Thanks.
(In reply to comment #27)

> exactly what we do today even at JLS8+ - that requires adding annotations
> to Name nodes, some thing I am not very excited about, but can do if
> needed.

That would further increase the memory foot print since Names are even more
ubiquitous than Types ...
(In reply to comment #27)

> We can certainly tread the middle path to avoid the pain in the UI 
> component, but a question: if we consistently return a QualifiedType for 
> JLS8+ whether or not there are annotations AND continue to do what we do 
> today for JLS4-, wouldn't all of your codebase anyway have to change ?

I guess even at JLS8+ you want us to construct a SimpleType except when there
are annotations - In that case we can return a QualifiedType and given all
yours have no type annotations right now, none of them would have to change.
(In reply to comment #27)
> Just to be sure: The last part is just an academic point - right ? (A)
> simply follows the present practice of returning empty lists and does not
> involve creation of Annotated* variants.

Exactly.

> The only way I see it wouldn't have to change is if we continue to do
> exactly what we do today even at JLS8+ - that requires adding annotations
> to Name nodes, some thing I am not very excited about, but can do if
> needed.

Adding annotations on the Name node would definitely be wrong.

I was mainly concerned about third-party clients of the DOM AST. I know that JDT UI has to adapt to JLS8 anyway, and we can fix these problems in BETA_JAVA8. But I think e.g. JDT UI from 3.8 would see many bugs if it ran against BETA_JAVA8 of JDT Core with this change. (We don't plan to use that setup in practice, but it shows problems that third-party clients could face.)

OTOH, my concern is really just a guess right now, and it might not be that bad. Let's just go with the "QualifiedType(SimpleType...)" for now. If it turns out to be a real problem, we can still deal with that later. Either with a separate conversion for old AST levels, or by using "SimpleType(QualifiedName...)" iff the structure is representable that way (e.g. for 1.7 code).
(In reply to comment #30)

> Adding annotations on the Name node would definitely be wrong.

That part of the spec is under flux, but JSR335, in some forms of 
reference expressions, the parser cannot tell between a Name and a Type
and will end up creating Names. In the type form the constituent type names
they may be annotatable. Note that the last published EDR for 308 is 
silent on reference expressions.
(In reply to comment #31)
> (In reply to comment #30)
> 
> > Adding annotations on the Name node would definitely be wrong.
> 
> That part of the spec is under flux, but JSR335, in some forms of 
> reference expressions, the parser cannot tell between a Name and a Type
> and will end up creating Names.

We can always ensure that the Name node on the compiler side shows up a
Type node on the DOM side - so there should be no need to add annotations
for Name nodes even this case.

All design questions are answered and we can get back to work - Thanks 
everyone.
(In reply to comment #30)

> bad. Let's just go with the "QualifiedType(SimpleType...)" for now. If it
> turns out to be a real problem, we can still deal with that later. Either
> with a separate conversion for old AST levels, or by using
> "SimpleType(QualifiedName...)" iff the structure is representable that way
> (e.g. for 1.7 code).

(Captured notes from a design conversation with Markus)

More complications: 

We seem to be in a bind (pun intended!)

"java.util.List" - Unless bindings are resolved, the new approach would 
naively would wrap java as a SimpleType and util as a QualifiedType - 
which would be "wrong". When bindings are available, we can do the right
things - this results in a situation where the ASTs would look completely
different based on whether bindings are requested or not.

While presently some types show up as names, in the new order some
names will start showing up as Types.

This is perhaps immaterial to a client which says do not resolve bindings.
But I gather there could be clients that could request the parse tree once
with and once without bindings and may be surprised if they are structurally
not the same. It is a huge unknown at this point how those clients would fair,
what is the amount of work involved for them etc.

I thought of a hidden micro pass at JLS8 when bindings are not requested
where using a AST visitor we would compute the package name lengths for 
QTR and PQTR and capture them. But given the various ways in which names 
could  be hidden, shadowed and obscured this may not prove to be a micro 
pass after all and could be very expensive with processing of class paths 
and  resolution of many types of nodes and such.

Three possible ways out:

(1) Just do what we now - but add annotations property to Name nodes.
(2) Invent AnnotatedSimpleName and AnnotatedQualifiedName subtypes and
leave the present SimpleName and QualifiedName as intact supertypes,
but provide annotations() property retriver method at the supertype
level.

(3) Follow the present scheme, do not do either of (1) or (2), but if
we notice annotations in a place where we would have presently created
a Name, switch gears and create a Type instead.

I like (2) as of now, but Markus is leaning towards (3).

I worry (3) could create some very ugly code and a good bit of rewrite as the use of various methods we presently use would not be possible due to type
hierarchy clash - unless we dilute type safety and it also entails checks everywhere for presence of annotations to execute a different conversion. 

(1) and (2) simply persist/perpetuate the present ambivalence/confusion
around Names and Types. (1) would waste memory while (2) would not.
(1) does not involve new node types, (2) does.

(1) and (2) also mean that the concern expressed in comment#26 about
expecting a lot of client side code/tests to be perturbed would vanish
and looks like a win for all.

At least for the time being I may end up picking (2) as it means not
getting bogged down with (3) which is considerably more work for all.
In that event, I would be open to switching to (3) at a later time
if there are strong arguments and consensus - (I am not opposed to (3)
in principle, just fear getting bogged down there at the moment)

As (1) and (2) also mean lot less work in the near future for all of us,
by opting for this approach it is not as though big investments are called 
from anyone now that would have to be thrown away if we switch to (3).

All on CC: - Let us know if we have overlooked some really simple/neat 
solution. TIA.
Thanks for the summary. I just wanted to add an epiphany I had at the end of the discussion:

The current name vs. type distinction is actually quite nice: You see immediately where a syntax-based parser cannot distinguish between package and type name any more. That's the point where a classpath is necessary to have more information. In that scheme, a name stays a name until proven to be a type (e.g. because it has type arguments or annotations).

> (2) Invent AnnotatedSimpleName and AnnotatedQualifiedName subtypes and
> leave the present SimpleName and QualifiedName as intact supertypes,
> but provide annotations() property retriver method at the supertype level.

That "annotations() property retriver method" would be quite strange, since it wouldn't be a rewritable property, but just an accessor.
(In reply to comment #33)

> (1) and (2) simply persist/perpetuate the present ambivalence/confusion
> around Names and Types. (1) would waste memory while (2) would not.
> (1) does not involve new node types, (2) does.
> 
> (1) and (2) also mean that the concern expressed in comment#26 about
> expecting a lot of client side code/tests to be perturbed would vanish
> and looks like a win for all.
> 
> At least for the time being I may end up picking (2) as it means not

Actually I should be asking: Between (1) and (2) is there a preference
from the UI side ? Perhaps you would prefer to opt for (1) as that entails
not dealing with new node types at all although it could waste some memory 
for the empty lists ?
(In reply to comment #34)

> > (2) Invent AnnotatedSimpleName and AnnotatedQualifiedName subtypes and
> > leave the present SimpleName and QualifiedName as intact supertypes,
> > but provide annotations() property retriver method at the supertype level.
> 
> That "annotations() property retriver method" would be quite strange, since
> it wouldn't be a rewritable property, but just an accessor.

Perhaps I am using non-standard terminology. What I meant to say
was instead of adding annotations() method in AnnotatedSimpleName,
I would add it in SimpleName - when called on a true SimpleName, it
would throw unsupported operation exception, while when called on
a node that is statically typed to be SimpleName, but is dynamically
an instance of AnnotatedSimpleName, it would return the child list.

I thought this way, there could be a set of clients that could manipulate
the annotations without actually encoding a new node type in their code.
Perhaps I am overlooking something ?

This is the approach I am using presently in the WIP patch v0.4 for
bug 391890 - where Type declares:

protected ASTNode.NodeList annotations = null;

and

	public List annotations() {
		if (this.annotations == null) {
			unsupportedIn2_3_4(); 
		}
		return this.annotations;
	}

Otherwise these would have to be replicated in half a dozen or so places.
From a OOP perspective, this appears the right way as we factor out the
common attributes and behavior as far up in the hierarchy as possible.

Again, let me know if I have overlooked some concern(s)
(In reply to comment #34)

> The current name vs. type distinction is actually quite nice: You see
> immediately where a syntax-based parser cannot distinguish between package
> and type name any more. That's the point where a classpath is necessary to
> have more information. In that scheme, a name stays a name until proven to
> be a type (e.g. because it has type arguments or annotations).

There is one further complication here: JSR308 requires annotations on
a package qualified top level type name to precede the package name: i.e

    Object o = (@Annot java.util.List) null;  // legal.
    Object p = (java.util.@Annot List) null;  // illegal: syntax error.

So using the presence of annotations to convert to type strategy would
create a wrong parse tree - java would end up as a Type instead of Name
and that would automatically make util a QualifiedType.

:)
(In reply to comment #37)

>     Object o = (@Annot java.util.List) null;  // legal.
>     Object p = (java.util.@Annot List) null;  // illegal: syntax error.

Sorry for the piecemeal updates creating a flurry of mails.

The following program actually compiles fine with javac 8b56:

// ---
public class X {
    Object o = (@Marker java.util.List) null;  // legal.
    Object p = (java.util.@Marker List) null;  // illegal: syntax error.

}

@java.lang.annotation.Target ({java.lang.annotation.ElementType.TYPE_USE})
@interface Marker {
}

but I believe that is a bug in javac - eclipse rejects the program: 
Latest EDR states: "A type annotation appears before the type, as in 
@NonNull String or @NonNull java.lang.String. A type annotation
appears before the package name, if any"

In any event, whether the latter form is legal or not is a moot point.
The former is legal and there the annotations really annotate the
type and not the package name.
(In reply to comment #36)
I'd rather cast to AnnotatedSimpleName and call annotations() there. A design that throws UnsupportedOperationExceptions should have a very good reason for doing so -- saving one instanceof/cast is not worth the pains of getting UOEs depending on input data.
The whole DOM API is very straightforward: All getters/setters behave equally, and all properties are also available via StructuralPropertyDescriptors and can always be manipulated via ASTRewrite.

The unsupportedIn2_3_4() is a different case: There, we could have deprecated the whole JLS4 API and added a separate JLS8 package, but instead, we just require clients to change the AST level. As soon as they've done the switch, some API methods consistently throw UOEs when used with a wrong AST level.


(In reply to comment #37)
That's indeed a hard one. 

>     Object p = (java.util.@Annot List) null;  // illegal: syntax error.
... would be legal if 'util' was a type and 'List' was a nested type of 'util'.

>     Object o = (@Annot java.util.List) null;  // legal.
... could also mean that 'java' is an annotated type and 'util.List' are nested types of 'java'.

Does that really mean the targeted element of an annotation and hence the "syntax error" in p depends on the classpath? That sounds soo wrong ... and it would explain why we have such a hard time finding a solution here.
(In reply to comment #39)
> (In reply to comment #36)
> I'd rather cast to AnnotatedSimpleName and call annotations() there. A
> design that throws UnsupportedOperationExceptions should have a very good
> reason for doing so -- saving one instanceof/cast is not worth the pains of
> getting UOEs depending on input data.

But I was assuming that this class of clients which can manipulate annotations
without encoding the new type would have first checked for the availability
of the ANNOTATIONS_PROPERTY in the property descriptors and only when present
would invoke annotations() which then is guaranteed to not throw UOE. It will
return either an empty list or a populated list.

Having no client side coding experience of these AST APIs it is likely
I am over estimating the usefulness of this coding pattern.

> The whole DOM API is very straightforward: All getters/setters behave
> equally, and all properties are also available via
> StructuralPropertyDescriptors and can always be manipulated via ASTRewrite.

In the scheme I was proposing, SimpleName would not claim
to have the structural property ANNOTATIONS_PROPERTY at *any* JLS level.
It is just that the annotations() child list retriever method would be
"available" at that node by virtue of OOP pull up but would throw 
unsupported operation exception if ever called on a dynamic SimpleName.

On the richer Type hierarchy, otherwise I need to provide identical methods
and declarations in half a dozen places.

With this explanation, do you still see an issue ? This is somewhat the
same thing done in the abstract BodyDeclaration class - see getModifiers()
method the field "ASTNode.NodeList modifiers".

In summary, what I was/am proposing for scheme (2) of comment#33 is:

Name would declare (sorry in previous comments I implied SimpleName would)

protected ASTNode.NodeList annotations = null;

and

	public List annotations() {
		if (this.annotations == null) {
			unsupportedIn2_3_4(); 
		}
		return this.annotations;
	}

The property list of SimpleName and QualifiedName would be unchanged at
all levels - in fact these entire classes would be untouched.

AnnotatedSimpleName and AnnotatedQualifiedName would provide additional
ANNOTATIONS_PROPERTY over and above their respective super type's list.

> The unsupportedIn2_3_4() is a different case: There, we could have
> deprecated the whole JLS4 API and added a separate JLS8 package, but
> instead, we just require clients to change the AST level. As soon as they've
> done the switch, some API methods consistently throw UOEs when used with a
> wrong AST level.

They would behave identically in the scheme I am proposing too.

> (In reply to comment #37)
> That's indeed a hard one. 
> 
> >     Object p = (java.util.@Annot List) null;  // illegal: syntax error.
> ... would be legal if 'util' was a type and 'List' was a nested type of
> 'util'.

Yes,

> >     Object o = (@Annot java.util.List) null;  // legal.
> ... could also mean that 'java' is an annotated type and 'util.List' are
> nested types of 'java'.

Yes, 

> Does that really mean the targeted element of an annotation and hence the
> "syntax error" in p depends on the classpath? That sounds soo wrong ... and
> it would explain why we have such a hard time finding a solution here.

The line is a bit blurred: We report "Syntax error, type annotations are 
illegal here", but in actual implementation terms, this error is reported
at semantic analysis time and the choice of the term "Syntax error" is our
own because that is what it is : misplaced annotations.

As for the spec itself - the syntax sections permit the annotations and
are rejected in prose elsewhere per my citation earlier.

The grammar change below would allow 

Object p = (java.util.@Annot List) null;

being:

ReferenceType:
[Annotations] UnannReferenceType

UnannReferenceType:
Identifier [TypeArguments] {.[Annotations] Identifier [TypeArguments]}

I see the only open question before continuing on the prototype is the
one in comment#35.
(In reply to comment #40)

Just to forestall any potential confusion: 

> 	public List annotations() {
> 		if (this.annotations == null) {
> 			unsupportedIn2_3_4(); 
> 		}
> 		return this.annotations;
> 	}
> 
> The property list of SimpleName and QualifiedName would be unchanged at
> all levels - in fact these entire classes would be untouched.

and the constructors of SimpleName and QualifiedName would leave
this.annotations untouched (null) at all JLS levels so annotations()
above would throw UOE predictably if ever called on a dynamic SimpleName
or dynamic QualifiedName.
(In reply to comment #33)

> Three possible ways out:
> 
> (1) Just do what we now - but add annotations property to Name nodes.
> (2) Invent AnnotatedSimpleName and AnnotatedQualifiedName subtypes and
> leave the present SimpleName and QualifiedName as intact supertypes,
> but provide annotations() property retriver method at the supertype
> level.
> 
> (3) Follow the present scheme, do not do either of (1) or (2), but if
> we notice annotations in a place where we would have presently created
> a Name, switch gears and create a Type instead.
> 
> I like (2) as of now, but Markus is leaning towards (3).

Actually given we have avoided creating additional classes for the Type
hierarchy under the stipulation that memory concerns should/could be 
addressed via (a) bug 150657 and/or (b) the approach outlined in the
last para of comment#26, I think (1) is a better strategy at least for
now. I'll work on this and we can revisit it later if there is a need.
Some further complicating scenarios that UI and other 3rd party clients
must be prepared to handle:

(1) A "pure" (i.e only new targets) SE8 annotation can occur in a SE7 location.
In that case, the annotation does not presently decorate the type reference in 
the compiler AST, but is instead attached to the element declared by the SE7 
construct.

(2) There could be annotations with hybrid SE7 and SE8 targets (see bug 391331).
In that case the spec calls the annotation to appear twice in the AST once
attached to the SE7 declared item and once at the type reference. This split is
possible only when bindings are requested => The ASTs will look different when
bindings are requested.
Fix and tests for bug 391890 have been released via
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=c3894f02481a65e7c5a6b2e211e3716b20cd9dd8

ASTRewrite changes need closer scrutiny.

A word on where annotations actually sit:

0. TypeParameter - Annotations are on the TyppeParameter
1. PrimitiveType - Annotations are on the PrimitiveType
2. SimpleType(SimpleName) - Annotations are on the SimpleType
3. SimpleType(QualifiedName) - Annotations are on the QualifiedName
4. QualifiedName(SimpleName) - Annotations are on the QualifiedName
5. QualifiedName(AnotherQualifiedName) - Annotations are on the QualifiedName
6. QualifiedType(AnotherQualifiedType) - Annotations are on the QualifiedType
7. QualifiedType(SimpleType) - We never create these
8. ParameterizedType(Type) - Annotations are on Type
9. WildcardType - Annotations are on the WildcardType.

Perhaps (3) and (8) are the odd ones out. Both create interesting issues
in visitors if I try to bubble them up - Even textually flattening the
tree poses some challenges - I take that as being indicative of trouble
other visitors will have too and opted for the present design.

For (8) @ReadOnly List<@English String> - it appears more intuitive to
read it as ReadOnly List of English Strings - rather than Readonly English 
Strings List.
Steps to add a new property to a node type in DOM/AST on the BETA_JAVA8 
branch: (You can use the changes made to SimpleType.java in the patch
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=c3894f02481a65e7c5a6b2e211e3716b20cd9dd8
as a boiler place)

1. Update Copyright of node type's class to contain the disclaimer:

 * This is an implementation of an early-draft specification developed under the Java
 * Community Process (JCP) and is made available for testing and evaluation purposes
 * only. The code is not compatible with any specification of the JCP.

2. Update class's Javadoc as needed.
3. Add the new ChildListPropertyDescriptor
4. Declare the new property descriptors list:
	/**
	 * A list of property descriptors (element type:
	 * {@link StructuralPropertyDescriptor}),
	 * or null if uninitialized.
	 * @since 3.9
	 */
	private static final List PROPERTY_DESCRIPTORS_8_0;
5. Initialize the new properties descriptors in the class's static 
initializer block.
6. Update accessor method propertyDescriptors() so that based
on JLS levels, the right descriptors are returned.
7. Declare field to capture new property as needed.
8. Update any javadoc in constructor.
9. Initialize (7) here based on JLS level.
10. Update internalGetChildListProperty as needed.
11. Update clone0:
12. Update accept0:
13. Provide property accessor/retriever method:
14. Update memSize() and treeSize();
15. subtreematch: Update ASTMatcher as needed.
16. Update NaiveASTFlattener as needed.
17. Update ASTRewriteAnalyzer.java
18. Update ASTRewriteFlattener.java
19. Add tests.
20 Request code review.
>     Object o = (@Annot java.util.List) null;  // legal.
>     Object p = (java.util.@Annot List) null;  // illegal: syntax error.

Srikanth, please take this to the jsr308 EG to fix the spec. The second form should be the correct one.

The current spec says in 2.1 ad 1.: "A type annotation appears before the type, as in @NonNull String or @NonNull java.lang.String. A type annotation appears before the package name, if any." This is bad.

Unlike other programming languages, Java has always strived to be precise and unambiguous. It should keep grammatical concepts in the grammar and not defer them to a second, context-dependent compiler phase. Moreover, this is the only place where annotations don't appear directly in front of the type. The same arguments as given for annotations on array types (2.2.1) also apply here.

Furthermore, the current spec precludes further language enhancements. At one time, we may want to add annotations to package references, and this is not easily possible any more if "@Annot java.util.List" cannot mean that "java" or "java.util" is annotated.


(In reply to comment #45)
This would make for a good wiki page.
(In reply to comment #46)
> >     Object o = (@Annot java.util.List) null;  // legal.
> >     Object p = (java.util.@Annot List) null;  // illegal: syntax error.
> 
> Srikanth, please take this to the jsr308 EG to fix the spec. The second form
> should be the correct one.

Will do. I see that this was discussed in Jan 2012 and here are the arguments
heard, some verbaitim, some the gist of:

// --
Arguments for the change to java.lang.@A Object include:
 * more uniform with respect to nested classes
 * easier for people to interpret, and possibly easier to implement
 * allows future extensions such as annotations on packages

Arguments for the current @A java.lang.Object include:
 * more aesthetically pleasing, at least to some people; does not break up
   the unit "java.lang.Object"; unlike the "OuterClass" type prefix, the
   "java.lang." package prefix feels like a part of the type
 * the change primarily improves the syntax for annotations on fully-qualified
   nested types.  Maybe those do not come up that often in practice, and
   maybe the change would make the syntax worse in the common case.
// ---

Gist of subsequent comments: 

// ---
If and when package reference annotations get introduced, the syntax could
be: 
    (@A java).lang.Object 
// ---

// -----
Also,  the current scheme seems more in keeping with rules for
qualifiers and cast expressions across dots for method calls.
As in:
   (long)aString.length()
not
   aString.(long)length();
// -------

// -----
The uniformity of

   p1.p2.@A C1

with

   p1.p2.C1.@A C2

is not worth much because I don't think nested type names are usually 
qualified in the first place.

// -------
Is Java SE going to support annotating a specific use of a 
package name (as opposed to a package declaration) in the next 10 years? 
Probably not.

// ---

Annotations on expressions/statements (more plausible than on 
package names) will face the problem of grouping alluded to earlier: 
(@A java).lang.Object - but 1000 times worse. So let's cross that bridge 
when we come to it, and perhaps apply it to package names if the need is 
there.

// ---

I didn't quite understand this last part about the 1000 time worse part,
Do you ?
(In reply to comment #47)

> // ---
> 
> Annotations on expressions/statements (more plausible than on 
> package names) will face the problem of grouping alluded to earlier: 
> (@A java).lang.Object - but 1000 times worse. So let's cross that bridge 
> when we come to it, and perhaps apply it to package names if the need is 
> there.
> 
> // ---
> 
> I didn't quite understand this last part about the 1000 time worse part,
> Do you ?

Never mind. I do understand it now and it does not change the argument for
java.lang.@Annot Object anyway, so I'll bring this up and see what comes.
> [...] so I'll bring this up and see what comes.

Thanks. The "more aesthetically pleasing" argument is not that relevant, since fully-qualified types are rare in practice (and they are not aesthetically pleasing anyway). +1 for a more regular grammar.
(In reply to comment #45)
> Steps to add a new property to a node type in DOM/AST on the BETA_JAVA8 
> branch:
> 
> ...
> 14. Update memSize() and treeSize();

are thee methods ever used? All I can find is one test that checks that

  x.subtreeBytes() > 0

I see that this one entry is actually API, so we can't change anything.
I'm just curious to learn why these methods are there in the first place.
> > 14. Update memSize() and treeSize();

As you can see in the Javadoc (no @since tag) and via Show Annotations, ASTNode#subtreeBytes() has been there since day one. I guess it was added for debugging purposes (but it's not really useful in practice, since it doesn't include bindings).

Today, we show the size in the head of the ASTView. The method can also serve as a lesson in API design (don't make stuff API just because you can...).
(Modulo bugs) The DOM/AST work for 308 is complete! 

Many thanks to Jay and Manoj.

ASTRewrite project is under way. There are several patches that Manoj and
Jay should refresh, polish, self-review and request Markus for a review.
Resolving. Any issues found by client code will be handled in fresh bugs.

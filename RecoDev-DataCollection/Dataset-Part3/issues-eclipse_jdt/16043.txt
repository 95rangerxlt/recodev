Build 20020514

JDT should provide a preference to control whether the catch block generated by 
Surround With Try/Catch contains e.printStackTrace or not.

Build 20020514

JDT should provide a preference to control whether the catch block generated by 
Surround With Try/Catch contains e.printStackTrace or not.
this could be done similar to 'filecomment': Define a template 'throwsblock' 
that would contain code like
e.printStackTrace

try/catch would enter this code between the catch block brackets.

(a wak point is that the template knows that the exception name is 'e')
doing it via template is fine, but the default should not be e.printStacktrace. 
This is not what exception handling is about <g>

defer to after 2.0
What about adding a task for implementing the catch clause?
[eg]
>doing it via template is fine, but the default should not be 
>e.printStacktrace. 
>This is not what exception handling is about <g>

At the moment we have

try{
 exceptionThrowingMethod();
}catch(Exception e){}

Thats what I see often in code of colleagues too. 
So e.printStacktrace() is an improvment.
Perhaps the best would be to rethrow the catched exception. To force the 
programmer to think about.


[eg]
>doing it via template is fine, but the default should not be 
>e.printStacktrace. 
>This is not what exception handling is about <g>

At the moment we have

try{
 exceptionThrowingMethod();
}catch(Exception e){}

Thats what I see often in code of colleagues too. 
So e.printStacktrace() is an improvment.
Perhaps the best would be to rethrow the catched exception. To force the 
programmer to think about.


I agree that throwing another (probably unchecked) exception is the safest
default.

It would be nice to use the chaining from JDK 1.4 but this could
be emulated with a new subclass of RuntimeException for compatibilies sake.

>What about adding a task for implementing the catch clause?
if we do it, we would have to do it consistently we generate stub code in many 
places (override method, quick fix). We have done this for JUnit and found that 
it is cumbersome to manage such tasks. Something to revisit after 2.0
[refactoring] [code manipulation]
this is now addressed by customizable code templates

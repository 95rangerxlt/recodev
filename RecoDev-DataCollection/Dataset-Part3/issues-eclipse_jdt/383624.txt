Created attachment 217920
Original implementation of code generation from 2010.

BETA_JAVA8:

In order to make it more manageable by breaking it into chunks, the commit in 
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=831d96bc5763622ed503192c35bfd6688abedd96, did not include
the files that implement code generation support for JSR308.

After code review, spec review and testing is over for what has already
been released (grammar + parser changes, AST construction, symbol/type
resolution ...), we should release the rest of the changes that deal with
code generation.

I'll post a patch that consists of the pending changes.

Created attachment 217920
Original implementation of code generation from 2010.

BETA_JAVA8:

In order to make it more manageable by breaking it into chunks, the commit in 
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=831d96bc5763622ed503192c35bfd6688abedd96, did not include
the files that implement code generation support for JSR308.

After code review, spec review and testing is over for what has already
been released (grammar + parser changes, AST construction, symbol/type
resolution ...), we should release the rest of the changes that deal with
code generation.

I'll post a patch that consists of the pending changes.
Created attachment 217922
Code generation merged and upto date as of Jun 2012
Consults attachments in bug 287648, in case of aggressive garbage 
collection.
The following items will be reviewed as part of code review 
for the current bug since they were skipped during review of
the bug 383624 as these are really code generation concerns:

All instances of getAllAnnotationContexts
AnnotationContext
AnnotationTargetTypeConstants
AnnotationCollector
Annotation#getLocations
Annotation#isRuntimeInvisible
Annotation#isRuntimeVisible
Annotation#isRuntimeTypeInvisible
Annotation#isRuntimeTypeVisible
From https://bugs.eclipse.org/bugs/show_bug.cgi?id=390891#c0 I am moving
the item:

(1) "Verify that HasTypeAnnotations bit is consistently set." to here.

--------------

Other concerns that need to be borne in mind:

(2) Also check ATTR_TYPE_ANNOTATION value - is this a specifiedd constant ?
(3) Who are the users of TypeReference.traverse(ASTVisitor, ClassScope) ?
On BETA_JAVA8 there are none and there appear to be none on the patch
to be revived too ?
Created attachment 222116
Updated patch as of 10-Oct 2012
Is anyone currently working on this?
Approx. 10 days from now I'd like to either consume this in bug 392099 and friends *or* I could give it a try driving this bug to completion.
(In reply to comment #6)
> Is anyone currently working on this?
> Approx. 10 days from now I'd like to either consume this in bug 392099 and
> friends *or* I could give it a try driving this bug to completion.

In about 10 days time, I plan to start work on it - I need to bring some
DOM/AST patches to a shape where they could be handed over to Jay for taking
them to completion.

One complication is that there are several changes to class file representation
of type annotations that are in flight - the published spec is old (Jun/Jul).
I am asking for a revised spec with upto date changes - this may be sometime in coming.
(In reply to comment #7)
> (In reply to comment #6)

> > *or* I could give it a try driving this bug to completion.

My plan is to break this bug down to several tasks and perhaps you can work
on some of them based on your time availability. The patch by Olivier is
likely to be partial as well stale given several changes that have happened/ are happening.
Many thanks !
Please see GrammarCoverageTests308.java which offers near 100% coverage
of the impacted grammar rules to test that type annotations are accepted
where should be and rejected where they should be. These could be handy
to put together tests for code generation. These are mostly negative tests
and would need massage.
Thanks a lot Andy and team for your offer of help here.
Created attachment 229927
Latest patch (work in progress)

Hopefully the patch is created ok (created with git).

This is an updated version of the previous patch to conform to the JSR308 spec as of 1st April 2013. It is not yet finished but I wanted to share some progress. It fails about 20 of the 64000 tests right now and I'll be sending a separate email about those to the relevant parties.

Notes:
- Code generation for all the target_types *except* those related to method/constructor references (the compiler itself doesn't seem to be code gen'ing for those yet, so hard to hook in!).

- Code generation split to include the new attributes alongside the right construct (the method/field itself or down on the code attribute).

- type_path construction still being worked on. Simple cases are OK but more elaborate cases being worked through. (I'm looking at you Mr com.package.something.OuterClass.InnerClass<@A String>.@A InnerClass2.InnerClass3<String, @A Integer>[][]@A[] )

- some reflective tests added which actually run and unpack the attributes to verify the format.

- Disassembler updated to produce javap like output (e.g. locations = [INNER_TYPE, TYPE_ARGUMENT(2)])

- Couple of Parser changes to ensure HasTypeAnnotations bit being set correctly.

Known issues:

- those failing tests (new format for locations affecting some TypeAnnotationSyntaxTests)

- more type_path tests

- need Method/Constructor reference tests/impl (waiting on code gen)

- Verify all changes in here are still necessary - still one or two that might be superfluous.

- bit of debug left in right now

- some variables/methods have incorrect names

- javadoc required in places

- problem with multicatch and losing annotations on some component exception types
(In reply to comment #12)

> Notes:
> - Code generation for all the target_types *except* those related to
> method/constructor references (the compiler itself doesn't seem to be code
> gen'ing for those yet, so hard to hook in!).

Jesper Moller has contributed a patch for this work which is in the review
pipeline - I expect to release it in a couple of days.
(In reply to comment #13)

> Jesper Moller has contributed a patch for this work which is in the review
> pipeline - I expect to release it in a couple of days.

This is now released. If you notice something amiss, raise a bug with a
minimal example and link it as a blocker to https://bugs.eclipse.org/bugs/show_bug.cgi?id=400875. TIA.
Created attachment 230054
Patch 1 of 2: Original patch just reworked to fix merge conflicts

This is the original patch before I made any changes, applied to BETA_JAVA8 (actually, for me, on top of "2344c6f Fixed Bug 406181 - [1.8][compiler][codegen] IncompatibleClassChangeError when running code with lambda method.")
Created attachment 230055
Patch 2 of 2: my changes for jsr308 on top of patch 1 of 2

Now the latest changes to implement the latest JSR308 spec (1st April). This patch applies on top of the previous patch, so you can see what I changed beyond the original patch.
I just appended the two patches that I believe help us through the IP process. I hope they apply ok...

Implementation notes, describing the end result after both patches applied:

- ClassFile extended to generate class file attributes at appropriate places, type declarations, member declarations and on code attributes.

- TypeAnnotationCodeStream is a new code stream subtype that overrides methods from code stream that need to add attributes (e.g. invoke, _new, invokedynamic, etc). The invokedynamic one is a little messy (lots of args).  Callers to these methods have been adjusted where necessary to pass in the type reference so that it can be used to compute the typepath for an attribute.

- ExtendedAnnotation is being used to represent a TypeAnnotation - could be renamed to TypeAnnotation (and the interface to ITypeAnnotation)

- Parser adjusted in two ways:
  - HasTypeAnnotation bit flowed across a few more constructs (in some cases a type reference did not have it when one it its component parts did)
  - catch block handling, the annotations are copied from the argument to the exception type (as they can only be type annotations). (Followed the pattern of the other place where this is done)

- Big changes in LocationCollector (in Annotation.java) related to type path computation. Important: to compute the INNER_TYPE path element correctly, we need to be working with resolved types for the type references. 

- Disassembler now takes new attributes apart and produces output very similar to javap

- TypeAnnotationSyntaxTests - adjusted to cope with new type path format.

- TypeAnnotationTest - ~100 new tests for the type annotation code gen.

This latest version also generates the method/constructor reference based attribute info.
Created attachment 230194
Original patch with minimal rework to pass all existing tests

This is the original patch from Olivier with as few changes as possible to get it to compile and run all jdt core tests clean. It doesn't not implement the current JSR308 spec. Patch created with git diff.
Created attachment 230195
Implements JSR308

Second patch, this applies on top of the previous patch and adjusts it to implement the JSR308 spec as of 1st April 2013.
Created attachment 230367
another updated version of the original patch

recent BETA_JAVA8 changes made the patches not apply cleanly, reworked them and readding them here.  Apply this one then the second one.
Created attachment 230368
Andys patch to apply on top of Oliviers

Applied on top of previous patch brings it inline with the 1st April JSR308 spec.
(In reply to comment #20)
> Created attachment 230367 [details]
> another updated version of the original patch
> 
> recent BETA_JAVA8 changes made the patches not apply cleanly, reworked them
> and readding them here.  Apply this one then the second one.

I cleaned up my review pipeline for 4.3, starting on this now.
(In reply to comment #20)
> Created attachment 230367 [details]
> another updated version of the original patch
> 
> recent BETA_JAVA8 changes made the patches not apply cleanly, reworked them
> and readding them here.  Apply this one then the second one.

Thanks, released this patch here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=de8aa9940086fe152901aa168536f30670945804.

Review comments/Follow up actions (mostly notes to self):

The second installment of the patch needs to be checked to see if it addresses
these issues and if not follow up bugs must be raised to have them taken 
care of:

(0) Copyright is stale in: TypeAnnotationTest, InstanceOfExpression, Statement,
StackMapFrameCodeStream, TypeAnnotationCodeStream, ASTRecoveryPropagator, 
CodeSnippetClassFile, CodeSnippetReturnStatement, IAttributeNamesConstants, 
IExtendedAnnotation, ILocalVariableReferenceInfo, 
IRuntimeInvisibleTypeAnnotationsAttribute,
IRuntimeVisibleTypeAnnotationsAttribute, ClassFileReader, ExtendedAnnotation, 
FieldInfo, LocalVariableReferenceInfo, Messages, MethodInfo, 
RuntimeInvisibleTypeAnnotationsAttribute, 
RuntimeVisibleTypeAnnotationsAttribute, messages.properties.

(1) JCP disclaimer is missing or duplicated in: AllocationExpression, 
MessageSend, QualifiedAllocationExpression, Statement, CodeStream, 
CodeSnippetAllocationExpression, IExtendedAnnotationConstants, ClassFileReader

(2) @since tags need updating in: IAttributeNamesConstants, IExtendedAnnotation, 
IExtendedAnnotationConstants, ILocalVariableReferenceInfo, 
IRuntimeInvisibleTypeAnnotationsAttribute, 
IRuntimeVisibleTypeAnnotationsAttribute

(3) These files incorrectly refer to 1.7 or 1_7 and should be updated to 
1.8 and 1_8: TypeAnnotationTest, ClassFile (2 places), CodeSnippetClassFile, 
IExtendedAnnotation, IExtendedAnnotationConstants,
IRuntimeInvisibleTypeAnnotationsAttribute

(4) IRuntimeVisibleTypeAnnotationsAttribute claims type annotations were 
added in 1.5. Needs to be fixed.

(5) TypeAnnotationTest: Many tests are disabled, need to check if all are
reenabled, test output needs to be scrutinized for correctness and comparison 
with javac.

(6) We need to inspect all uses of org.eclipse.jdt.internal.compiler.codegen.CodeStream.invoke(byte, MethodBinding, TypeBinding)
to see if we are dropping type annotations inadvertently somewhere. For instance 
in AllocationExpression.java, we are dropping annotations on type arguments 
if the call is routed through a synthetic method.

(7) Likewise all (the only) calls to org.eclipse.jdt.internal.compiler.codegen.CodeStream.new_(TypeBinding)
should be inspected to see if type annotations are being dropped.

(8) Should org.eclipse.jdt.internal.compiler.codegen.TypeAnnotationCodeStream.invoke(byte, MethodBinding, TypeBinding, TypeReference[]) be checking for 
ASTNode.HasTypeAnnotations ?

(9) CastExpression: If a cast is annotated, but does not require run time 
check cast, what happens to the annotations ?  should we always be generating 
a cast if type annotation persistence demands it ? 

(10) Check if intersection casts can carry type annotations and whether we 
handle them properly.

(11) All callers of org.eclipse.jdt.internal.compiler.codegen.CodeStream.newArray(TypeReference, ArrayBinding)
pass null for the first argument. 
org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression.generateCode(BlockScope, CodeStream, boolean) continues to call the old method - type 
annotations are probably dropped due to this.
Likewise for multianewarray

(12) Since the time of the original patch, things have changed so it is no 
longer possible to annotate types in class literals. Need to verify if this 
is consistently cleaned up by later patch.

(13) TypeAnnotationCodeStream.addAnnotationContext methods have stale 
commented out code - needs to be deleted.

(14) ASTRecoveryPropagator: Are these changes still relevent ? Is the right JLS 
levels being checked for ?

(15) IExtendedAnnotation and ExtendedAnnotation:  entire files needs to be 
reviewed against spec from an implementablity stand point. Javadoc is 
outdated in some places.

(16) Javadoc differences between IRuntimeInvisibleTypeAnnotationsAttribute 
and IRuntimeVisibleTypeAnnotationsAttribute need to be looked into. 
(empty collections mentioned non-uniformly)

(17) ExtendedAnnotation claims it is default implemenation of IAnnotation - 
should be IExtendedAnnotation  ??

(18) Check AnnotationTargetTypeConstants and IExtendedAnnotationConstants for up 
to date values.

(19) LocalVariableReferenceInfo claims it is default implementation of 
ILocalVariableTableEntry ??

(20) RuntimeInvisibleTypeAnnotationsAttribute references bogus entries in 
javadoc.

(21) ClassFile and Disassembler changes need to be scrutinized closely.

(22) Type annotations are handled/partially handled for: Object construction,
type arguments of generic methods and constructor invocations, 
array allocation (partial) cast expression, instanceof expressions. A bunch 
of other scenarios are missing. Need to be be studied closely against the
specification to make sure all gaps are addressed by the subsequent patch.

(23) Also see comment#3 for certain code that was not reviewed earlier and 
needs to be reviewed in the present context.

---
Olivier, you just made a huge contribution to JDT's Java 8 effort - Thanks !
(In reply to comment #23)

> The second installment of the patch needs to be checked to see if it
> addresses
> these issues and if not follow up bugs must be raised to have them taken 
> care of:

I didn't make many of the clean ups that could have been done before
release since it would cause problems with the follow on overlay patch 
by Andy. These issues will be cleaned up in due course.
(In reply to comment #21)
> Created attachment 230368 [details]
> Andys patch to apply on top of Oliviers
> 
> Applied on top of previous patch brings it inline with the 1st April JSR308
> spec.

I released first batch of changes that don't involve any IP and constitute
mere clean ups here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=e4718c224cab1ce3081aa85532a7ec7da527a7d0

These changes are in the nature of updates to copyrights, providing the JCP 
disclaimer, updates to @since tags, backing out some code changes and restoring
things to a prior state, reordering fields etc.

Andy, some questions/observations:

(1) I don' see any material changes in ExplicitConstructorCall, 
CastExpression and CodeSnippetMessageSend.

(2) Is the change in MethodInfo material ? Please confirm.

(3) Some of the files have copyright string that reads 2000, 2009, 2013 - 
is this intentional ? As far as I have seen we use the form 2000, 2013.

(4) I see that you have backed out the change in ASTRecoveryPropagator. I 
had my own suspicions about this file. But I wonder whether Olivier made 
these changes because some UI tests were failing in the sbsence of this 
change. Alternatively this change may not be needed anymore because the parser has undergone (due to the grammar changes) some changes that render this 
unnecessary.
Created attachment 230941
Andy's patch to apply on HEAD of BETA_JAVA8

Patch consisting of 28 files yet to be reviewed.
(In reply to comment #27)
> Created attachment 230941 [details]
> Andy's patch to apply on HEAD of BETA_JAVA8
> 
> Patch consisting of 28 files yet to be reviewed.

This will be referred to as the "third installment", after Olivier's patch
and the follow on clean up patch by Andy both of which are released to 
BETA_JAVA8 branch.

Updated review comments/Follow up actions (mostly notes to self):

The third installment of the patch needs to be checked to see if it addresses
these issues and if not follow up bugs must be raised to have them taken 
care of:

(0) Copyright is stale in: TypeAnnotationTest, StackMapFrameCodeStream, 
TypeAnnotationCodeStream,  ASTRecoveryPropagator, IExtendedAnnotation,  
ExtendedAnnotation, Messages, MethodInfo, messages.properties.

(1) JCP disclaimer is missing or duplicated in:  CodeStream, 
IExtendedAnnotationConstants

(2) @since tags need updating in: IExtendedAnnotation, 
IExtendedAnnotationConstants,  

(3) These files incorrectly refer to 1.7 or 1_7 and should be updated to 
1.8 and 1_8: TypeAnnotationTest, ClassFile (2 places), IExtendedAnnotation, 
IExtendedAnnotationConstants,

(4) TypeAnnotationTest: Many tests are disabled, need to check if all are
reenabled, test output needs to be scrutinized for correctness and comparison 
with javac.

(5) We need to inspect all uses of org.eclipse.jdt.internal.compiler.codegen.CodeStream.invoke(byte, MethodBinding, TypeBinding)
to see if we are dropping type annotations inadvertently somewhere. For instance 
in AllocationExpression.java, we are dropping annotations on type arguments 
if the call is routed through a synthetic method.

(6) Likewise all (the only) calls to org.eclipse.jdt.internal.compiler.codegen.CodeStream.new_(TypeBinding)
should be inspected to see if type annotations are being dropped.

(7) Should org.eclipse.jdt.internal.compiler.codegen.TypeAnnotationCodeStream.invoke(byte, MethodBinding, TypeBinding, TypeReference[]) be checking for 
ASTNode.HasTypeAnnotations ?

(8) CastExpression: If a cast is annotated, but does not require run time 
check cast, what happens to the annotations ?  should we always be generating 
a cast if type annotation persistence demands it ? 

(9) Check if intersection casts can carry type annotations and whether we 
handle them properly.

(10) All callers of org.eclipse.jdt.internal.compiler.codegen.CodeStream.newArray(TypeReference, ArrayBinding)
pass null for the first argument. 
org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression.generateCode(BlockScope, CodeStream, boolean) continues to call the old method - type 
annotations are probably dropped due to this.
Likewise for multianewarray

(11) TypeAnnotationCodeStream.addAnnotationContext methods have stale 
commented out code - needs to be deleted.

(12) ASTRecoveryPropagator: Are these changes still relevent ? Is the right JLS 
levels being checked for ?

(13) IExtendedAnnotation and ExtendedAnnotation:  entire files needs to be 
reviewed against spec from an implementablity stand point. Javadoc is 
outdated in some places.

(14) Javadoc differences between IRuntimeInvisibleTypeAnnotationsAttribute 
and IRuntimeVisibleTypeAnnotationsAttribute need to be looked into. 
(empty collections mentioned non-uniformly)

(15) ExtendedAnnotation claims it is default implemenation of IAnnotation - 
should be IExtendedAnnotation  ??

(16) Check AnnotationTargetTypeConstants and IExtendedAnnotationConstants for up 
to date values.

(17) LocalVariableReferenceInfo claims it is default implementation of 
ILocalVariableTableEntry ??

(18) RuntimeInvisibleTypeAnnotationsAttribute references bogus entries in 
javadoc.

(19) ClassFile and Disassembler changes need to be scrutinized closely.

(20) Type annotations are handled/partially handled for: Object construction,
type arguments of generic methods and constructor invocations, 
array allocation (partial) cast expression, instanceof expressions. A bunch 
of other scenarios are missing. Need to be be studied closely against the
specification to make sure all gaps are addressed by the subsequent patch.

(21) Also see comment#3 for certain code that was not reviewed earlier and 
needs to be reviewed in the present context.
Hi Srikanth,

> Andy, some questions/observations:
> 
>(1) I don' see any material changes in ExplicitConstructorCall, 
>CastExpression and CodeSnippetMessageSend.

Yep, looks like they may have had some changes in for a while that got backed out but the copyright messages weren't also removed.

>(2) Is the change in MethodInfo material ? Please confirm.

Looks like just a reordering change, not necessary to include that.  Probably came about due to trying to engineer the split patches between what I'd done and what Olivier did.

I was developing some level of patch blindness by the end :) I'm happy to fix anything up that you want me to.

>(3) Some of the files have copyright string that reads 2000, 2009, 2013 - 
>is this intentional ? As far as I have seen we use the form 2000, 2013.

I wasn't quite sure of the form we were using for split dates. My error.

>(4) I see that you have backed out the change in ASTRecoveryPropagator. I 
>had my own suspicions about this file. But I wonder whether Olivier made 
>these changes because some UI tests were failing in the sbsence of this 
>change. Alternatively this change may not be needed anymore because the parser >has undergone (due to the grammar changes) some changes that render this 
>unnecessary.

I had been assuming the latter but I haven't run any tests beyond all the jdt core tests.

As I say, if you want me to make any further changes let me know. I did review all the testcase expected output for type annotations against javac (b81) and the spec (1st May spec).
Actually, bit more digging:

>>(1) I don' see any material changes in ExplicitConstructorCall, 
>>CastExpression and CodeSnippetMessageSend.
>
>Yep, looks like they may have had some changes in for a while that got backed
>out but the copyright messages weren't also removed.

These were cases were Oliviers patch changed the code but didn't introduce the copyright updates (my first stab with Oliviers patch was doing the absolute minimum to get it to compile cleanly and pass the tests). My patch added the copyright updates so that is why they show up as only comment changes in my patch.

The changes in the files in the original patch were minimal - passing a null parameter on some calls so that it avoided the additional method invocation of calling something that just added the additional null first parameter and invoked something else - seemed reasonable.
Created attachment 230969
Andy's patch to apply on HEAD of BETA_JAVA8

I released a micro patch with further clean up and hooking up the tests
here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=c9bdf68b361a7010457e9cb0971191d8d2775ec2

The remaining 26 files attached to this file will have to go through the
CQ review process (ater code review) as they constitute the core 
implementation.
Hi Srikanth, I have some bug fixes for this stuff - shall we get the patch in then handle these under other issues? (They are much smaller changes) or do you want me to rework the smaller patch?
(In reply to comment #32)

> Hi Srikanth, I have some bug fixes for this stuff - shall we get the patch
> in then handle these under other issues? 

Yes, please. Let us tackle them in a follow on patch that addresses issues 
raised during code review.
I released the changes in the file Parser, PQTR, PSTR and ASTRecoveryPropagator
via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=1155b311a647fc5f126edd0c5e6b818f225baee0 as these are not
integral to the code generation implementation and are bug fixes to exisiting
code (or revert unnecessary code in the case of ASTRP).

I made the following changes before releasing:

(1) PSTR & PQTR: I moved the tagging of HasTypeAnnotations to the other
chained constructor as this is cleaner.

(2) A couple of places I changed code of the form if(x!=0) to if (x != 0)

(3) Renamed the loop label typeAnnoSearch to annotationSearch.

(4) Parser: Replicated the changes made in consumeArrayCreationExpressionWithoutInitializer into consumeArrayCreationExpressionWithInitializer. Added a new test for this
scenario to TypeAnnotationTest

(5) Parser: Deleted the code change that start with the comment
"// Catch parameter annotations can only be type annotations; move to the type"
This is a wrong assumption. Catch parameters can be annotated right at SE5 level.
If I leave in the code, the following does not compile with eclipse:

// --
public class X {
	public static void main(String[] args) {
		try {
			
		} catch (@NonNull NullPointerException npe) {
			
		}
	}
}

@interface NonNull {
	
}
// ---

It should and does with JDK6,7 and 8 (we report an error, "only annotations
that specify explicit target allowed here")

As a result of deleting this code, 4 tests in TypeAnnotationTests fail:
test055_codeblocks_exceptionParameterMultiCatch,
test052_codeblocks_exceptionParameter,
test053_codeblocks_exceptionParameter,
test054_codeblocks_exceptionParameter.

We will have to find out what is the right thing to do and address them
in a follow up patch.
Created attachment 230994
Andy's patch to apply on HEAD of BETA_JAVA8

Patch with remaining 22 files that needs review and CQ clearance.
Andy, I expect to complete one round of review and submit the patch for CQ review
and clearance later today. Any issues found can be addressed in follow up bugs.

We need a statement from you confirming you authored the code and have 
the rights to donate the code to Eclipse under the EPL for inclusion in 
future Eclipse releases.

See https://bugs.eclipse.org/bugs/show_bug.cgi?id=402892#c7 for a template. TIA.
(In reply to comment #35)
> Created attachment 230994 [details]
> Andy's patch to apply on HEAD of BETA_JAVA8
> 
> Patch with remaining 22 files that needs review and CQ clearance.

The 4 failing tests are disabled in this patch by prefixing the test names
with _.
Andy, the change in ArrayAllocationExpression looks suspicious. As a result,
we now generate bad code (verify error due to operand stack underflow) for
this program. I am surprised that our test suite didn't catch this:

// ---
public class X {
	public static void main(String[] args) {
		X [][][] x = new X[10][10][];  
	}
}

Is the change from explicitDimCount to this.dimensions.length intentional
for the 3rd argument to multianewarray ?
I don't have a type annotations reference compiler handy right now to compare,
but looks like we emit bad annotations for 

// --
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public class X {
	public static void main(String[] args) {
		X [][] x = new X @TA [] @TA [] { { null }, { null } };   
	}
}

@Target(ElementType.TYPE_USE)
@interface TA {
	
}
// ---

All the type annotations are clumped together and attributed to the outer new.

Code:

  public static void main(java.lang.String[]);
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=4, locals=2, args_size=1
         0: iconst_2
         1: anewarray     #16                 // class "[LX;"
         4: dup
         5: iconst_0
         6: iconst_1
         7: anewarray     #1                  // class X
        10: aastore
        11: dup
        12: iconst_1
        13: iconst_1
        14: anewarray     #1                  // class X
        17: aastore
        18: astore_1
        19: return
      LineNumberTable:
        line 6: 0
        line 7: 19
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0      20     0  args   [Ljava/lang/String;
              19       1     1     x   [[LX;
      RuntimeInvisibleTypeAnnotations:
        0: #23(): NEW, offset=1
        1: #24(): NEW, offset=1
}
(In reply to comment #39)
> I don't have a type annotations reference compiler handy right now to
> compare,
> but looks like we emit bad annotations for 

Program snippet should be:

/ -- 
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public class X {
	public static void main(String[] args) {
		X [][] x = new X @TA [] @TB [] { { null }, { null } };  
	}
}

@Target(ElementType.TYPE_USE)
@interface TA {
	
}

@Target(ElementType.TYPE_USE)
@interface TB {
	
}

@TA and @TB are both attributed to the outer array.

On another note, should the spec allow annotations at dimensions that
are not actually allocated ? e.g:

/ --
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public class X {
	public static void main(String[] args) {
		X [][][] x = new X @TA [2] @TB [] @TC [];
	}
}

@Target(ElementType.TYPE_USE)
@interface TA {
	
}

@Target(ElementType.TYPE_USE)
@interface TB {
	
}

@Target(ElementType.TYPE_USE)
@interface TC {
	
}

Should the application of @TB and @TC be allowed ? It looks strange to allow
annotations on non-existent dimensions. Also could result in conflicts when
those dimensions are actually allocated later.
Hi Srikanth,

> Is the change from explicitDimCount to this.dimensions.length intentional
for the 3rd argument to multianewarray ?

Casting my mind back, looks like something I changed relatively early on and then didn't revisit as no jdt core tests were failing. I think it should be changed to pass both the explicit dims and the dimensions.  The actual dimensions (as opposed to those explicitly declared) are needed in the type path calculation, annotationsOnDimensions won't tell us the actual dimensions if there are no annotations on any dimension.

> public static void main(String[] args) {
>   X [][] x = new X @TA [] @TA [] { { null }, { null } };   
> }

I was encountering a couple of things here yesterday as I was writing tests for something else. I'll take a look at your example, yes one of them should have a type path of ARRAY.

Sorry the patch is causing you grief !
I have a fix for :
  X [][] x = new X @TA [] @TB [] { { null }, { null } };  

I'll raise another bug to cover it and a couple of other small fixes.

I'm thinking about the annotated catch parameters now:

} catch (@Foo Exception e) {

As we can't always assume they are type annotations, I guess we have to 'do something' when we can determine that it is a type annotation, so on resolution of @Foo.  I have a working patch that, post resolution of the Argument annotations will copy them to the exception type. I'll raise a separate issue for this. I'm also adding some more testcases that mix in inner types with these constructs, not sure I have enough.
(In reply to comment #42)
> I have a fix for :
>   X [][] x = new X @TA [] @TB [] { { null }, { null } };  
> 
> I'll raise another bug to cover it and a couple of other small fixes.

Sounds good. To the extent possible, I would prefer separate bugs for separate
issues. You can always tell me the order in which they should be reviewed and
released if there are dependencies.

Please provide the contributor declaration (comment#36)
Further review comments:

IExtendedAnnotation:

    - Fixed javadoc of getTypeParameterIndex to say type parameter of class
or method. Likewise for getTypeParameterBoundIndex.
    - getAnnotationTypeIndex: fixed javadoc to say -1 65535 instead of -1 255.

ExtendedAnnotation:

    - Is dropping the index for the intersection cast in readTargetInfo.
    - May return null for org.eclipse.jdt.core.util.IExtendedAnnotation.getLocalVariableTable() ?
The interface documents an empty array being returned.

MultiCatchExceptionLabel

    - getAllAnnotationContexts(int, List) always returns 0, is this intentional ?
Likely not, since this messes up the exception table index computation ?

CodeStream(s): Is the method org.eclipse.jdt.internal.compiler.codegen.CodeStream.newArray(TypeReference, ArrayBinding) needed ? 

AnnotationContext:

Carries a comment: // annotationsOnDimensions might be null but the dimensions
may still be important. In some cases they are not on the reference.

Do you have an example scenario for this case ? There are also a few other
places where I see dimensions being passed in additions to annotationsOnDimensions. If the latter is not null, its length gives the
dimensions and if it is null, dimensions should not matter ? 

ClassFile:

addFieldAttributes: Needs a relook. When a field declaration carries a type
annotation (or for that matter when a type annotation occurs in any place 
where a Java SE5 annotation can occur, we leave it annotating the declared 
entity - i.e the type annotation is not moved to the type.) So code fragments 
like if (fieldType.bits & ASTNode.HasTypeAnnotations) != 0) may not get
executed at all. Until the resolve phase, we don't know whether an annotation
is a type declaration and so the HasTypeAnnotations bit cannot be set in
these places.
Created attachment 231061
Final patch to input for IP review/approval

I completed one round of review correlating implementation to specification.
I will make another deep review pass correlating from specification to
implementation, but this is in a good enough shape for release.
Many of the concerns raised earlier are addressed by Andy's patch already
and here is the consolidated and updated list of concerns that need further
investigation:

Revised list of issues that need follow up/further scrutiny:

(1) We need to inspect all uses of CodeStream.invoke(byte, MethodBinding, TypeBinding)
to see if we are dropping type annotations inadvertently somewhere. For instance 
in AllocationExpression.java, we are dropping annotations on type arguments 
if the call is routed through a synthetic method.

(2) Likewise all (the only) calls to CodeStream.new_(TypeBinding) should be 
inspected to see if type annotations are being dropped.

(3) Should TypeAnnotationCodeStream.invoke(byte, MethodBinding, TypeBinding, 
TypeReference[]) be checking for ASTNode.HasTypeAnnotations ?

(4) CastExpression: If a cast is annotated, but does not require run time check 
cast, what happens to the annotations ? We seem to be dropping them ?

(5) Intersection casts are not handled.

(6) Type annotations on catch parameters may not be handled properly. Also 
should check multicatch. The following tests are disabled now:

test055_codeblocks_exceptionParameterMultiCatch,
test052_codeblocks_exceptionParameter,
test053_codeblocks_exceptionParameter,
test054_codeblocks_exceptionParameter.

(7) Verify error with:
// --
public class X {
	public static void main(String[] args) {
		X [][][] x = new X[10][10][];  
	}
}

(8) Type annotations on different dimensions appear clumped together in:
// --
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public class X {
	public static void main(String[] args) {
		X [][] x = new X @TA [] @TA [] { { null }, { null } };   
	}
}

@Target(ElementType.TYPE_USE)
@interface TA {
	
}

(9) ExtendedAnnotation may be violating javadoc of 
IExtendedAnnotation.getLocalVariableTable() ?

(10) MultiCatchExceptionLabel.getAllAnnotationContexts needs a relook. Always 
returns 0. I think since we flatten the multi catch into a sequence of catches, 
is this method better placed in ExceptionLabel ?

(11) CodeStream(s): Is the method CodeStream.newArray(TypeReference, 
ArrayBinding) needed ? 

(12) ClassFile.addFieldAttributes: Needs a relook. When a field declaration 
carries a type annotation (or for that matter when a type annotation occurs in 
any place where a Java SE5 annotation can occur, we leave it annotating the 
declared entity - i.e the type annotation is not moved to the type.) So code 
fragments like if (fieldType.bits & ASTNode.HasTypeAnnotations) != 0) may not 
get executed at all. Until the resolve phase, we don't know whether an 
annotation is a type declaration and so the HasTypeAnnotations bit cannot be set 
in these places.
I will postpone the work on replicating code annotation in bug 391331 until this is resolved.
I have started the IP review process - this will proceed right after
the contributor questionaire/declaration is filled out (comment#36)
> AnnotationContext:
>
> Carries a comment: // annotationsOnDimensions might be null but the dimensions
> may still be important. In some cases they are not on the reference.
>
> Do you have an example scenario for this case ? There are also a few other
> places where I see dimensions being passed in additions to 
> annotationsOnDimensions. If the latter is not null, its length gives the
> dimensions and if it is null, dimensions should not matter ? 

Consider:

===
import java.lang.annotation.*;
@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE_USE)
@interface A {}

public class Code {
  @A String [][] field;
}
===

For @A the classfile will contain:

java.lang.String[][] field;
    descriptor: [[Ljava/lang/String;
    flags: 
    RuntimeVisibleTypeAnnotations:
      0: #7(): FIELD, location=[ARRAY, ARRAY]

So there were no annotations on the dimensions (so it was null) but we needed to know the dimensions so that we could compute [ARRAY, ARRAY].  As an alternative to passing dimensions we could have initialized annotationsOnDimensions to new Annotation[]{null,null}
Before you catch it in your spec checking review Srikanth, there is a bug with the type parameter index byte for CAST related type annotations. I'm fixing it as part of the intersection cast tests.
Response to comment 45, point 10:

> (10) MultiCatchExceptionLabel.getAllAnnotationContexts needs a relook. Always
> returns 0. I think since we flatten the multi catch into a sequence of 
> catches, is this method better placed in ExceptionLabel ?

Can delete that code, I didn't appreciate the flattening was going on. So remove that method and the branch of code that was calling it. I'll raise (another) bug to cover this simplification.
(In reply to comment #50)
> Before you catch it in your spec checking review Srikanth, there is a bug
> with the type parameter index byte for CAST related type annotations. I'm
> fixing it as part of the intersection cast tests.

I already spotted the += 3 and the = (byte) 0 :) but didn't call it out since
it is covered anyway by comment#46 point 5. Thanks!
(In reply to comment #49)

> So there were no annotations on the dimensions (so it was null) but we
> needed to know the dimensions so that we could compute [ARRAY, ARRAY].  As
> an alternative to passing dimensions we could have initialized
> annotationsOnDimensions to new Annotation[]{null,null}

Good point, thanks for the clarification.
> (12) ClassFile.addFieldAttributes: Needs a relook. When a field declaration 
> carries a type annotation (or for that matter when a type annotation occurs in 
> any place where a Java SE5 annotation can occur, we leave it annotating the 
> declared entity - i.e the type annotation is not moved to the type.) So code 
> fragments like if (fieldType.bits & ASTNode.HasTypeAnnotations) != 0) may not 
> get executed at all. Until the resolve phase, we don't know whether an 
> annotation is a type declaration and so the HasTypeAnnotations bit cannot be
> set in these places.

Although we don't copy them or move them to the type reference in this situation, the HasTypeAnnotation bit is currently set eagerly on the field declaration if *any* annotations are found (Parser.consumeEnterVariable, line 3547).  This feels a slight of an abuse of the bit as it can be set for non type annotations. It causes no harm but may send us hunting for some type annotations that won't be found during code gen. If we'd rather have that bit only set when we know for certain there are type annotations then I'll have to instead set it during resolution (as you mention).

As far as I'm aware the checking of that bit is always done post resolution (so we can rely on the result) - or am I forgetting a codepath? Are we thinking about error scenarios where resolution fails for some reason?
Andy's implementation and tests released here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=79c1182746ff2f44f9956aeaf2f61882a4911acb

Andy, please provide a follow on patch with suitable copyright updates - I'll
wait for that patch before resolving this ER.

Thanks everyone.
(In reply to comment #46)
> Many of the concerns raised earlier are addressed by Andy's patch already
> and here is the consolidated and updated list of concerns that need further
> investigation:

I have spawned several bugs for the concerns raised so they
can be addressed individually.
Created attachment 231729
Modified copyright messages to include GoPivotal, Inc.

Changes to comments to add company affiliation.
For completeness I'll finish this bug by confirming:

I authored 100% of the patches I'm contributing.
I have the rights to contribute this to Eclipse.
I am willing to license this as EPL as stated in the file header comments I'm uploaded.
Copyright updates released here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=26e96a017b590b444a246c8fba814dc78fd85b77

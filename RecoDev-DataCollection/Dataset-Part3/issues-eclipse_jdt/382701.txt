This ER will serve as the top level umbrella entry to track semantic
analysis support for Lambda expressions & Method and constructor references.
(https://bugs.eclipse.org/bugs/show_bug.cgi?id=380501 will be used to
track support for default methods.)

Separate bugs will be spawned for unit tasks in this project and linked
to this entry.

When resolved, we would be able to reject every semantically illegal program
with a suitable/appropriate diagnostic. The further treatment of well
defined programs will be the subject matter of ERs that will be created
later.

This ER will serve as the top level umbrella entry to track semantic
analysis support for Lambda expressions & Method and constructor references.
(https://bugs.eclipse.org/bugs/show_bug.cgi?id=380501 will be used to
track support for default methods.)

Separate bugs will be spawned for unit tasks in this project and linked
to this entry.

When resolved, we would be able to reject every semantically illegal program
with a suitable/appropriate diagnostic. The further treatment of well
defined programs will be the subject matter of ERs that will be created
later.
Just adding a small test case from bug 384593

public class Action<T> {
    public void foo() {
    int i11 = (Integer) (final int x, MissingType<String, Integer> m) -> x;
    }
}
Should be rejected because of MissingType
Let us use this bug just as an umbrella/master ER for semantic analysis
and post all comments to individual bugs linked as as blockers of this
bug.
Concern #2 from https://bugs.eclipse.org/bugs/show_bug.cgi?id=385041#c7
is moved to here and will be addressed as a part of this work. 

(2) Decide fields of ReferenceExpression (only one of name/type/primary is
used see bug bug 380194 comment 53
(In reply to comment #3)
> Concern #2 from https://bugs.eclipse.org/bugs/show_bug.cgi?id=385041#c7
> is moved to here and will be addressed as a part of this work. 
> 
> (2) Decide fields of ReferenceExpression (only one of name/type/primary is
> used see bug bug 380194 comment 53

Update: the 'name' field (and the constructors taking a NameReference) appear to be obsolete already in current BETA_JAVA8. 
Remains the duality between TypeReference and Expression, which indeed seems to be inherent in a way. 
Is it naive asking about splitting this class into InstanceBasedReferenceExpression and TypeBasedReferenceExpression.
(In reply to comment #4)
> (In reply to comment #3)
> > Concern #2 from https://bugs.eclipse.org/bugs/show_bug.cgi?id=385041#c7
> > is moved to here and will be addressed as a part of this work. 
> > 
> > (2) Decide fields of ReferenceExpression (only one of name/type/primary is
> > used see bug bug 380194 comment 53
> 
> Update: the 'name' field (and the constructors taking a NameReference)
> appear to be obsolete already in current BETA_JAVA8. 

Certainly the constructor is obsolete. But the field is not really.
consumeReferenceExpressionTypeForm has a TODO comment "Handle ambiguity 
with NameReference."

> Remains the duality between TypeReference and Expression, which indeed seems
> to be inherent in a way. 
> Is it naive asking about splitting this class into
> InstanceBasedReferenceExpression and TypeBasedReferenceExpression.

When Name gets resurrected, we will have three + 1 base class to factor in
common behavior. 

I am not opposed to 4 classes - let's revisit this when we are at the bridge
to cross.
Created attachment 225695
First attempt at type analysis for lambdas

Simple first attempt at a patch, which implements a scope for lambdas (extends from MethodScope as the lambda behaves quite a bit like a method)

TODO:
 - The detection of functional interfaces is a simple first attempt.
 - error messages should be better
 - this only covers lambdas, I haven't worked on method and constructor references
 - no code generation yet, obviously

(Note: The patch is over 250 lines long but that's only really because of the diff markers and copyright comments. I am an Eclipse committer, but not on JDT, obviously).
I've set up a fork on GitHub where you may view patches:

https://github.com/jespersm/eclipse.jdt.core/tree/BETA_JAVA8
(In reply to comment #7)
> I've set up a fork on GitHub where you may view patches:
> 
> https://github.com/jespersm/eclipse.jdt.core/tree/BETA_JAVA8

I am not 100% sure, but I *think* eclipse IP process requires patches
to be attached to bugzilla by contributors. In any case that is the
standard process we have followed and I would request you to attach
a patch here, just to be safe.
(In reply to comment #8)
> (In reply to comment #7)
> > https://github.com/jespersm/eclipse.jdt.core/tree/BETA_JAVA8
> 
> I am not 100% sure, but I *think* eclipse IP process requires patches
> to be attached to bugzilla by contributors. In any case that is the
> standard process we have followed and I would request you to attach
> a patch here, just to be safe.

You are correct -- and everything I've committed into the GitHub fork has also been added as patches. I've just set this up to track my own progress, and edit patches once Anirban starts adding stuff, in case it differs a lot.
Has it been decided yet, where LambdaExpressions will be integrated in the AST inheritance tree? I see "LambdaExpression extends FunctionalLiteral" in some patches, which looks surprising to the naive reader:
- lambdas aren't literals, are they?
- lambdas share a lot with methods and I've already seen some copy/paste from AbstractMethodDeclaration to LambdaExpression.

My naive p.o.v. soon breaks because a lambda must be subtype of Expression, so we can't extend AbstractMethodDeclaration here. Is that your reasoning?

Two options come to mind:
- make LambdaExpression a very thin wrapper with a reference to a - say - LambdaMethodDeclaration, or
- push some reusable code from AbstractMethodDeclaration up to ASTNode.

Sorry, if I'm fighting a non-issue. If alternatives have already been discussed please give a me a pointer so I can catch up. Thanks.
(In reply to comment #10)
> Has it been decided yet, where LambdaExpressions will be integrated in the
> AST inheritance tree? I see "LambdaExpression extends FunctionalLiteral" in
> some patches, which looks surprising to the naive reader:
> - lambdas aren't literals, are they?
> - lambdas share a lot with methods and I've already seen some copy/paste
> from AbstractMethodDeclaration to LambdaExpression.
> 
> My naive p.o.v. soon breaks because a lambda must be subtype of Expression,
> so we can't extend AbstractMethodDeclaration here. Is that your reasoning?

I originally hooked up LambdaExpression as a subtype of NullLiteral as a way
of silencing the rest of the phases of compilers from emitting various errors.
As null is always assignable to any reference, it was an effective way to short
circuit downstream components.

As you point out, LambdaExpression and ReferenceExpression must be derived 
from Expression.

I think any continued connection to Literals is likely intended as a stop
gap measure in the same spirit as the original subtyping from NullLiteral.

> Two options come to mind:
> - make LambdaExpression a very thin wrapper with a reference to a - say -
> LambdaMethodDeclaration, or

This is worth exploring. Though at the moment I am inclined to think we
should do it in a follow up bug. I am keen to review and release basic
infrastructure code for semantic analysis this week.

> - push some reusable code from AbstractMethodDeclaration up to ASTNode.

I am not hugely worried about code duplication via copy+paste
from AMD or its subtypes. Pushing them upwards could save some duplication
at the expense of implementing behavior at a level where it is not entirely
appropriate. We could chose to duplicate code with a clear cross referencing
comment on either side.
(In reply to comment #11)

> As you point out, LambdaExpression and ReferenceExpression must be derived 
> from Expression.

I figure that they share some common analysis (hooking up with a functional interface and using the expected type for further analyses), so I've put them under a common base, which should be abstract. Yes, that could be considered implementation inheritance, but they share some interface too, so it's not a bad smell.

> I think any continued connection to Literals is likely intended as a stop
> gap measure in the same spirit as the original subtyping from NullLiteral.

Actually I was in doubt as to what constituted a literal, since neither lambdas nor references actually compute anything (yet) what are they really? But I'd say that FunctionalLiteral should be renamed to FunctionalExpression and extend Expression, and so avoid Literal.

> I am not hugely worried about code duplication via copy+paste
> from AMD or its subtypes. Pushing them upwards could save some duplication
> at the expense of implementing behavior at a level where it is not entirely
> appropriate. We could chose to duplicate code with a clear cross referencing
> comment on either side.

The code duplication is not so bad once you have to take care of optional parameters, different interpretation of this, synthetic parameters (once we get to generating code), and whatnot: The argument list won't look too much like a method's argument list, since it (and the throws declaration) will have to be dynamically computed (see the definition of a function descriptor in the Lambda EDR, section 9.8) from the constituent interfaces. (I'm going to focus on that, next, to replace the simplistic detection introduced in bug 382702, org.eclipse.jdt.internal.compiler.ast.FunctionalLiteral.resolveFunctionalMethod(int, ProblemReporter), note the TODO)

BTW: I've pushed all the patches to Eclipse's Gerrit instance, which makes review a bit more fun and collaborative. I'll post the links in each bug, or you can search Gerrit.
View these patches in Gerrit:

https://git.eclipse.org/r/9907

https://git.eclipse.org/r/9908

https://git.eclipse.org/r/9912/
Patch in Gerrit (may be easier to view patch and easier to check out from using Git)

https://git.eclipse.org/r/#/c/9912/
(In reply to comment #12)

Thanks for filling in the rationale behind the current design. I just wasn't sure how much consideration went into the current solution. Your reasoning makes sense to me.

> Actually I was in doubt as to what constituted a literal, since neither
> lambdas nor references actually compute anything (yet) what are they really?

I'd agree with calling references "literals" (very similar to class literals),
but to me lambdas are more of a declaration (plus a reference to it), 
we might call them anonymous method/function declarations.

> BTW: I've pushed all the patches to Eclipse's Gerrit instance, which makes
> review a bit more fun and collaborative. I'll post the links in each bug, or
> you can search Gerrit.

Sure, Gerrit is great for detailed nit-picking :)
OTOH I'd consider the design of the AST class hierarchy a conceptual thing
for which bugzilla is still a good place, don't you think?

(In reply to comment #11)
> > - push some reusable code from AbstractMethodDeclaration up to ASTNode.
> 
> I am not hugely worried about code duplication via copy+paste
> from AMD or its subtypes. Pushing them upwards could save some duplication
> at the expense of implementing behavior at a level where it is not entirely
> appropriate. We could chose to duplicate code with a clear cross referencing
> comment on either side.

We already have precedents of code sharing via ASTNode or Expression for otherwise unconnected sub-classes. IF we go that way we could use the opportunity for documenting the different groups of sub-classes that share a particular piece of behaviour. I personally find this easier to maintain than (cross-referenced) duplicates, but this is not a strong objection. And once we need significantly different variants, duplication with modification may actually be the smoothest of all solutions.
(In reply to comment #15)
> (In reply to comment #12)

> Sure, Gerrit is great for detailed nit-picking :)
> OTOH I'd consider the design of the AST class hierarchy a conceptual thing
> for which bugzilla is still a good place, don't you think?

I apologize, I should I have chimed in with my preference much earlier
before Jesper spent cycles putting up things in gerrit. We had used gerrit
heavily for a month earlier and I was personally underwhelmed - I think
since I am going to be the primary reviewer for your patches, I would
personally prefer simple patches attached to bugzilla.

Later in the day, I'll post detailed comments on the initial infrastructural
work for semantic analysis.
I have looked at the various patches and overall much of the work is
in the right direction, though I have various changes to suggest. A write
up such the one below should ideally have preceded the work, I apologize
for being too swamped to have come up with that.

Let us use this bug for putting in place the basic infrastructure for semantic
analysis and handle other issues in blocking leaf bugs.

Here is what I would like to see in the "infrastructure" work:

(1) Proper hierarchical placement of LambdaExpression and ReferenceExpression:

    As rightly pointed out in comment#12, there is commonality between
LambdaExpression and ReferenceExpression that is worth modelling in the
abstraction. We need to cut the chord with literals, except perhaps for
still returning TypeBinding.NULL from certain code paths ("if needed", "may be")
in LambdaExpression/ReferenceExpression.resolveType if we still need 
downstream components to be silent.

   I think the hierarchy should be:

   Expression
       FunctionalExpression
          LambdaExpression
          ReferenceExpression

From the type system point of view, a lambda expression stands for a reference:
a reference to an object that implements the single abstract method of the
target type interface. I don't think we should worry about the "literal"
connotation that comes from a "particular" implementation.

(2) Implementation of a skeleton method for TypeBinding#getSingleAbstractMethod
(returns null or a PRB) and ReferenceBinding#getSingleAbstractMethod. The 
latter could at this point return null for non-interfaces and for interfaces
could ignore inheritance, object method redefinitions etc. If no single method
could be found, this method should ideally return a ProblemReferenceBinding
with ProblemReasons set to NoSuchSingleAbstractMethod. 

I can get Anirbhan to tighten the implementation on behalf of a different bug.

(3) Hooking up stub/skeleton/placeholder/minimal implementation of
resolveType method:

(a) Check that target type is an interface and otherwise report an error.
(b) Report error if the target interface does not define a single abstract
method. (see #2 above)
(c) create suitable scope. I don't think this will be reentered (scope == null
redundant)
(d) Propagate possibly elided type of lambda paramaters.
(e) Resolve arguments.
(f) Resolve body.
(g) Possibly return TypeBinding.Null

(4) Propagation of expected target type *into* the new classes. I see that
the patch attached to the current bug does this. But a later patch hoists some
of the analysis to the contexts. I don't think we should opt for this latter
approach. There is precedence in expected type propagation from Java 7
constructs and we need to augment that as the patch attached to this
bug does.

// ---------
(Now, Java 8 defines additional contexts (method invocation ...) where the
expected type/target type plays a role. In these places we should invoke a 
new method setExpectedTypeInInvocationContext() etc which has a valid
implementation (that delegates to setExpectedType) with the base implementation
being a NOP. 

However, this can be dealt with a in a separate bug, as it involves quite
a bit of magic work in overload resolution: Unless the lambda's target type
is known, we can resolve the overloaded method and unless we can resolve the
overloaded method, we can't determine the target type of the lambda.

Also per my memory, some of the additional contexts also impact
Java7 constructs in Java8. In these cases, they should delegate to 
setExpectedType after a check of the source level. (this piece can also 
come later as it is not connected to the present topic.)

I see that we also need a new type for the lambda bodies of the form
() -> 100, as the resolution of the misnamed "Statement" should treat
it as an implicit return statement, which won't happen automatically.
I'll raise a separate bug for this - we also need to chain the expected
type from the containing lambda.
)
// ------------

For the present implementing setExpectedType is good enough.

(5) I would withdraw the new LambdaScope class at this time. Not opposed
to this abstraction per se, but it can be deferred to a later time when
its motivation is fully clear. At the level of patch attached to this
bug all LambdaScope does is to forward the expectedResultType, which can
be otherwise achieved by making LambdaExpression implement ReferenceContext
and handlng LambdaExpressions pretty much the same way as is done for AMD.

(6) LambdaExpression should implement ReferenceContext. In the absence of
this, we would abort compilations at a coarser level than we should.

(7) Implement the traverse methods. In both ClassScope and BlockScope.
IIRC, 308 requires them in both scopes. Not sure, but it wouldn't hurt.
(See Argument#traverse)

(8) Provide implementation of ASTVisitor.visit and endVisit methods for
both the new types.

Editorial comments:

(1) Copyright update missing in LambdaExpression. Make sure to uniformly
call out your contribution with bug number in all modified files.

(2) Please get rid of the unused
org.eclipse.jdt.internal.compiler.ast.LambdaExpression.typeDeclaration

(3) Please rename org.eclipse.jdt.internal.compiler.ast.LambdaExpression.singleMethod to
singleAbstractMethod.

(4) I would cluster all the 3.9 APIs closer together where possible.
i.e newer problems can follow IllegalQualifierForExplicitThis2 (as of
this writing.)

(5) PolyExpressionInIllegalContext is too general. I would opt for
LambdaOrReferenceExpressionInIllegalContext. May be split it into two
so message text can unambiguously call out.

(6) Calling org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolveToType(BlockScope, TypeBinding) from org.eclipse.jdt.internal.compiler.ast.Argument.resolve(BlockScope) is 
problematic.

The new LocalVariableBinding created is tagged as being a non-argument,
various diagnostics would confuse arguments vs locals etc (redefineLocal()).
I would handle redeclaring/hiding/shadowing/obscuring related issues in
a different bug though. (The nesting of Method scopes could upset the
hiddenVariableDepth and could call for some massaging of code)

(see that your patch https://bugs.eclipse.org/bugs/attachment.cgi?id=225696
exhibits this problem)

(7) Argument resolution is traditionally handled NOT by deferring
to the LocalDeclaration#resolve and friends, but via org.eclipse.jdt.internal.compiler.ast.Argument.bind(MethodScope, TypeBinding, boolean). Please take a look at the caller's of this method.

(8) I can't see a use for org.eclipse.jdt.internal.compiler.ast.Argument.elidedType()

(9) We usually leave a space after the ) of the cast, so  ((LambdaScope)methodScope) should be  ((LambdaScope) methodScope)

A note on testing: We are trying to stabilize our testing against
b73/b74 JRE. There are still some failures we are trying to clean
up. Once that is declared green, you can test against the agreed
upon JRE. Your test entry point will be org.eclipse.jdt.core.tests.RunJDTCoreTests. Till then I am happy to run
all the regression tests for you as a part of the review/release process.

Every test we write, we want to confirm behavior against the reference
compiler. (b73/b74)

Please split the patches into tests vs code or even code and code as needed
at the moment. We will take up committer rights process in due course.

The suggested infrastructure can be amended as time goes and a clear need
emerges.

As these changes will impact other patches you have posted, I'll include
high level comments on them here itself using the recommended order of
review outlined by you.

(1) 381121: I don't see a test patch here ??
(2) 382727: the recommended way to disable a test is to prefix its name 
with an _. Also remember to post an updated list to bug 383608, so we don't 
lose track.
(3) 382727: "Duplicate local variable x" message - x is actually an argument.
Perhaps we could issue clearer new message here as a part of a separate
bug - we need to handle and test nested lambdas.
(4) 383096: Will review after infrastructure is in place and fix is massaged.
(5) 384687: Will review after infrastructure is in place and fix is massaged.
(6) 382702: We need to remove all the code around allowFunctionalInterface()
and use the propagation of the target type via setExpectedType() as mentioned
earlier.
(7) 398734: Would recommend eliminating all flow analysis from here and
handle it in a separate bug altogether at a later time.

Overall, I would say things look promising for someone starting to work
on JDT/Core anew. Thanks for your efforts.

Please a propose a patch with the suggested infrastructural changes and
I'll review and release on a priority basis.

(If needed, you can also split the work into LambdaExpression and ReferenceExpression portions)

Thanks!
(In reply to comment #17)

> (2) Implementation of a skeleton method for
> TypeBinding#getSingleAbstractMethod
> (returns null or a PRB) and ReferenceBinding#getSingleAbstractMethod. The 
> latter could at this point return null for non-interfaces and for interfaces
> could ignore inheritance, object method redefinitions etc. If no single
> method
> could be found, this method should ideally return a ProblemReferenceBinding
> with ProblemReasons set to NoSuchSingleAbstractMethod.

Correction: I meant to say ProblemMethodBinding (PMB) and not 
ProblemReferenceBinding

> I can get Anirbhan to tighten the implementation on behalf of a different
> bug.

See bug 399224

> (3) Hooking up stub/skeleton/placeholder/minimal implementation of
> resolveType method:

We can introduce as many IProblem constants as necessary so we are able
to issue a precise clearly worded message.

> a bit of magic work in overload resolution: Unless the lambda's target type
> is known, we can resolve the overloaded method and unless we can resolve the
> overloaded method, we can't determine the target type of the lambda.

Correction: Unless the lambda's target type is known, we *can't* resolve the overloaded method ...

> I see that we also need a new type for the lambda bodies of the form
> () -> 100, as the resolution of the misnamed "Statement" should treat
> it as an implicit return statement, which won't happen automatically.
> I'll raise a separate bug for this - we also need to chain the expected
> type from the containing lambda.

Not necessary. We can check if the lambda body is a block and if not
validate the return type then and there. Likewise, we can check if the
lambda body is a lambda expression and if so chain the expected type.

> (7) 398734: Would recommend eliminating all flow analysis from here and
> handle it in a separate bug altogether at a later time.

i.e everything not pertinent to the title of the bug should be in a
different patch on a different bug.
Jesper, let me know if finding time is going to be a problem this week.
The DOM/AST work for 308 is coming to completion and I can work on this
this week if needed. Since the infrastructure work will unblock other
tasks, I am keen to wrap this up soon.
Srikanth - it has been a bit of a task basically unravelling all the patches are starting it one step at a time, so I'm not sure I'd be able to finish it till late Thursday. Perhaps it'd be better if I post a patch of my current work, and you'd take it from there.
(In reply to comment #20)
> Srikanth - it has been a bit of a task basically unravelling all the patches
> are starting it one step at a time, so I'm not sure I'd be able to finish it
> till late Thursday. Perhaps it'd be better if I post a patch of my current
> work, and you'd take it from there.

Sounds good. Please do. We will avoid such situations in future by ensuring
that (a) you are working on well defined non-blcoker/leaf items and/or (b)
well defined projects such as flow analysis where you have made good progress
(c) reviews are prompt and patches don't pile up.
Created attachment 226290
Patch for as far as I've gotten (cleanly)

Srikanth - It came in just under 250 lines :-) and lots of it is copyright boilerplate, really :-|

I've addressed point 1), 2), 3)a+b and 4) above, and haven't retrofitted the tests yet (so haven't checked the formatting of the error message or PMB).

I hope you can use this as is, I'm leaving it for now -- if you check in (or attact a patch), I can continue on from there late Wednesday, if you want.
(In reply to comment #22)
> Created attachment 226290 [details]
> Patch for as far as I've gotten (cleanly)

Thanks, Here are the modifications I made. I know this is work in progress
that you have uploaded without opportunity to polish and so are not 
oversights per se.

(1) Renamed IProblem.NotAFunctionalInterface to TargetTypeNotAFunctionalInterface.
(2) In ReferenceBinding.getSingleAbstractMethod() eliminated multiple calls to
this.methods(), by capturing the value in local.
(3) instance method calls are not required to be prefixed with "this.", only
instance field accesses are.
(4) Same method: We can simply pass null for arguments and PMB will transform
it into Binding.NO_PARAMETERS. We don't want to create new objects.
(5) Same method: we centralize all hardcoded constants into either TypeConstants
or into ConstantPool. I replaced "function".toCharArray with TypeConstants.ANONYMOUS_METHOD. A trick to make sure internal names don't 
collide with user space names is to embed white spaces. 
(6) We should cache the PMB or the single abstract method.
(7) Fixed the error message: it was mangled.
(8) Simplified the signature of ProblemReporter#targetTypeIsNotAFunctionalInterface

Released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=b9ab827b0e2709263cd127badca5672535507466.

Congrats on your first commit - Thanks!
Released some missing pieces that complement previous commit via:
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=5da340dfbdee6d0d431864522bf5ee4b7e53f3e4
(In reply to comment #24)
> Released some missing pieces that complement previous commit via:
> http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
> ?h=BETA_JAVA8&id=5da340dfbdee6d0d431864522bf5ee4b7e53f3e4

Anirban, these two commits should completely unblock you and allow
you to proceed on bug 399224
Ouch, my patch omitted my version of FunctionalLiteral - must be an EGit PEBKAC error, I thought I'd added it to the index.
Sorry 'bout that.
Created attachment 226307
Test fixes for org.eclipse.jdt.core.tests.compiler.regression.CompilerInvocationTests

Introducing a new problem always triggers a change to this test. I'm not entirely sure of the purpose...
(In reply to comment #27)
> Created attachment 226307 [details]
> Test fixes for
> org.eclipse.jdt.core.tests.compiler.regression.CompilerInvocationTests
> 
> Introducing a new problem always triggers a change to this test. I'm not
> entirely sure of the purpose...

Thanks for catching it. I have released the patch via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=e8075a0df168dcda9adff16ce27919f4df5f2cda.

To avoid such problems in future, I have added CompilerInvocationTests to
RunAllJava8Tests via:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=2565f84b1b73e40321abe403fa7b5cce7eb56119

Note on testing: 

(1) Please use b74 - all tests should pass when run as RunJDTCoreTests
(2) Smoke test can be done via RunAllJava8Tests - this finishes in under
a couple of minutes and tells if you broke some 308/335 functionality.
(3) When in doubt, run (1)
(4) Unless you are very sure run (1)
(5) Run (1) :)
Created attachment 226315
Patch to cut FunctionalExpression's dependency on Literal

... since lambdas and references aren't literals.
(In reply to comment #29)
> Created attachment 226315 [details]
> Patch to cut FunctionalExpression's dependency on Literal
> 
> ... since lambdas and references aren't literals.

Thanks, released with a couple of minor changes. Expression's implementation
of reusableJSRTarget() is the right one and should not be overridden. By mistake
I also ended up deleting the javadoc on generateCode, but left it as is since
this method is a place holder.

Released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=7e9cb5a3c53e26b5cf1cdabebd4f0bb2f504c23d

Followed up with a bit more clean up on constructor chaining with:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=4152a87f3580e53749fa348690b4abc9a373bea9
Created attachment 226356
Actual activation of the semantic analysis inside the lambda expression

This variation reuses MethodScope, implements ReferenceContext (I still need to find out what the deal is there) and performs very simple resolving.

I have left TODOs instead of actual error messages, as I need to figure out how to do this best. For this reason, the patch doesn't contain new tests, only a fix of a single test which had an unknown variable, in NegativeLambdaExpressionsTest.test009. I've used another variable to silence the analysis, as to not confuse what's being tested.

So, to actually test the semantic validation, new tests will be submitted -- at first for the basic resolve() on the lambda body, and then more as I add error messages. I hope that approach is workable.
Created attachment 226357
Test case for basic semantic tests in lambdas

This test demonstrates the semantic checks which now work:
- Setting up a scope
- Resolving unknown names fails as expected.
- Resolving types of declared variables
- Resolving types of elided variables as per functional descriptor
- Checking of return expression (or lack thereof)
- Following the 'static'-ness of the enclosing method.
- Addressing a variable from enclosing method scope (for now ignoring effectively finals)
Thanks, the best way to progress is to work on leaf bugs and add as much of
code and tests as necessary for each bug. That way on each bug we are able 
to see what code/tests were added and verify whether all the necessary and
sufficient checks are in place. If we clump all work here, it will become a
problem.

No need to rework what has already been done, but in future let us use the 
present  bug only for adding boiler plate place holder code and relegate
any real code to leaf bug (raised afresh if needed).
(In reply to comment #33)
> Thanks, the best way to progress is to work on leaf bugs and add as much of
> code and tests as necessary for each bug. That way on each bug we are able 
> to see what code/tests were added and verify whether all the necessary and
> sufficient checks are in place. If we clump all work here, it will become a
> problem.

Right. I think the only remaining infrastructure item left from you outline in comment 17, is the traverse and ASTVisitor work -- I'll file that under a separate bug as a dependency.
(In reply to comment #31)
> Created attachment 226356 [details]
> Actual activation of the semantic analysis inside the lambda expression

Thanks, I released this patch with some minor edits:

(1) (I know this is copy pasted code)
if (this.scope != null) {
			return this.scope.compilationUnitScope().referenceContext;
		}
		return null;

is better written as:

return this.scope == null ? null : this.scope.compilationUnitScope().referenceContext;

(2) cleaned up comments stating the obvious.

Commit id: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=30ba2db951e79b89a330e1209e461b1c083d6de3

I'll follow this up shortly with another commit that cleans up a bunch of
things.
(In reply to comment #32)
> Created attachment 226357 [details]
> Test case for basic semantic tests in lambdas

Thanks, Released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=5b5c973a8216c08a1f2946e0c5b4a77da83dac27.

I verified that JDK8b74's diagnostics are equivalent. If you didn't check
explicitly this time, please do in future so we don't inadvertently encode
incorrect/suspect behavior.

All releaseable patches from you have been reviewed and released - others
attached to different bugs will require rework anyway due to the changes
done already.
(In reply to comment #35)

> I'll follow this up shortly with another commit that cleans up a bunch of
> things.

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=558c64a899c0debc518d6eb92e85f37b05902eba

(In reply to comment #34)
> (In reply to comment #33)

> Right. I think the only remaining infrastructure item left from you outline
> in comment 17, is the traverse and ASTVisitor work -- I'll file that under a
> separate bug as a dependency.

Patch above includes this change, along with a few other clean-ups.

One important implementation note: Returning TypeBinding.Null is *not*
a valid way of signalling an error. Either we should return null or a
Problem*Binding as needed. In most situations null is suitable enough
and a PRB or a PMB could be an overkill.

Note that TypeBinding.Null is a valid problem free binding that corresponds
to the null literal's type. It made it into the classes due to the (now)
historic (incorrect but convenient) connection to NullLiteral.

(In reply to comment #17)

> (7) Implement the traverse methods. In both ClassScope and BlockScope.
> IIRC, 308 requires them in both scopes. Not sure, but it wouldn't hurt.
> (See Argument#traverse)

I confirmed that lambda/reference expressions could be traversed only
in a block scope. So we should be good just with the block scope traverse
method.
Let us move all further work/patches to blocking bugs that the present 
bug depends upon.

We will use the present bug only for discussion of overarching design issues
and as a status tracker for the umbrella semantic analysis project.
(In reply to comment #37)
> One important implementation note: Returning TypeBinding.Null is *not*
> a valid way of signalling an error. Either we should return null or a
> Problem*Binding as needed. In most situations null is suitable enough
> and a PRB or a PMB could be an overkill.

Ok, good clarification, I never fully understood point (3g) above.

Thank you for your patience in bringing me up to speed, I hope my future contributions will bring 'less mess'!
(In reply to comment #39)
> (In reply to comment #37)
> > One important implementation note: Returning TypeBinding.Null is *not*
> > a valid way of signalling an error. Either we should return null or a
> > Problem*Binding as needed. In most situations null is suitable enough
> > and a PRB or a PMB could be an overkill.
> 
> Ok, good clarification, I never fully understood point (3g) above.

3g has to be read along with the earlier passage: "We need to cut the chord 
with literals, except perhaps for still returning TypeBinding.NULL from 
certain code paths ("if needed", "may be")" - Now we are fully hooked into
Expression hierarchy.

> Thank you for your patience in bringing me up to speed, I hope my future
> contributions will bring 'less mess'!

Actually, the quality of your patches are well above average/typical of a rank
beginner's work. Thanks.
A good way to check for parameter compatibility for bug 399534 is to synthesize
a suitably populated method binding for the anonymous method and call
MethodVerifier.isParameterSubsignature. See also MethodVerifier.doesMethodOverride

I am noticing some interesting behavior in javac - need to check if the spec
warrants it - Given the following program:

//----
import java.util.List;

interface I {
	void foo(List<String> ls);
}
public class X {
	void boo() {
		I i = (List l) -> {};
	}
	void goo() {
		I i = new I() {
			public void foo(List l) {
				
			};
		};
	}
}
// --------------




When compiled I get:

C:\jtests>C:\work\lambda-8-b74-windows-x64-21_jan_2013\bin\javac -cp c:\jtests X
.java
X.java:8: error: incompatible types: incompatible parameter types in lambda expression
                I i = (List l) -> {};
                      ^
1 error

The identical case with anonymous classes compiles fine.

Does anyone recall a part of the spec that would justify this ?
(In reply to comment #41)
> 
> Does anyone recall a part of the spec that would justify this ?

EDR 0.5.1 - Part E - Summary addresses this:

For a lambda expression, the descriptor's parameter and return types are compared to the expression. The lambda parameter types must exactly match those of the descriptor, while the body generally must be assignment-compatible with the descriptor's return type. [...]
(In reply to comment #42)
> (In reply to comment #41)
> > 
> > Does anyone recall a part of the spec that would justify this ?
> 
> EDR 0.5.1 - Part E - Summary addresses this:
> 
> For a lambda expression, the descriptor's parameter and return types are
> compared to the expression. The lambda parameter types must exactly match
> those of the descriptor, while the body generally must be
> assignment-compatible with the descriptor's return type. [...]

I see, thanks. In that case the reference I cited in comment#41 won't be useful
as it is and we may as well resort to equality comparison.
(In reply to comment #43)
> I see, thanks. In that case the reference I cited in comment#41 won't be
> useful
> as it is and we may as well resort to equality comparison.

Found it accurately:

15.27.3, under congruence of the lambda expression, bullet 2:

If the lambda parameters have explicitly-declared types, these types are the same as the parameter types of the descriptor.

(so we can put that reference near the equals check and/or test case)
Part A talks of a "well-formed" parameterized type in this passage:

"If F<T1...Tn> is a well-formed type, then the descriptor of F<A1...An> is the result of applying substitution [P1:=T1, ..., Pn:=Tn] to the descriptor of interface F. Otherwise, the descriptor of F<A1...An> is undefined." ...

Does anyone have a ready reference that defines this term ? Any code example
that would show an ill formed type ? Is bounds check failure what is alluded
to here ?
(In reply to comment #45)
> Part A talks of a "well-formed" parameterized type in this passage:

> Does anyone have a ready reference that defines this term ? Any code example
> that would show an ill formed type ? Is bounds check failure what is alluded
> to here ?

Yes. So, this question is closed.
Against my own request, I am releasing a big chunk of code (resolve &
analyze phases are completely in place for lambdas, analyze is a nop
for ReferenceExpressions) here via: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=1b6413921860c74cfa469f859f6fc627d6400adf

This should fix a whole slew of dozen or so bugs open in this space.
In the next couple of days, I will start adding tests to the respective
bugs and verifying things work ok, close them.

Take a look at how value-body lambda's are handled in the resolve
phase ;-)
(In reply to comment #47)

> Take a look at how value-body lambda's are handled in the resolve
> phase ;-)

That's clever... But you forgot to call the analyseCode on the expression, just to catch e.g. important assignments or dead code such as

Supplier<Boolean> bs = () -> (false && Math.random() > 0.5)

I'll get my previous unit tests in shape and resubmit them.
(In reply to comment #48)
> (In reply to comment #47)
> 
> > Take a look at how value-body lambda's are handled in the resolve
> > phase ;-)
> 
> That's clever... But you forgot to call the analyseCode on the expression,
> just to catch e.g. important assignments or dead code such as
> 
> Supplier<Boolean> bs = () -> (false && Math.random() > 0.5)

Jesper, the following code:

// ---
interface I<T> {
	T doit(int x);
}

class X {
	I<Boolean> i = (int x) -> (false && Math.random() > 0.5);
}
// -----

does trigger the warning. So does the one below:

// ----

interface I {
	boolean doit(int x);
}

class X {
	I i = (int x) -> (false && Math.random() > 0.5);
}
// ----

Why wouldn't the statement:

lambdaInfo = this.body.analyseCode(this.scope, methodContext, lambdaInfo);

in LambdaExpression.analyzeCode suffice ?


> I'll get my previous unit tests in shape and resubmit them.

Thanks!
(In reply to comment #49)

> Why wouldn't the statement:
> 
> lambdaInfo = this.body.analyseCode(this.scope, methodContext, lambdaInfo);
> 
> in LambdaExpression.analyzeCode suffice ?

You are right, it's fine.
From my understanding of the code, all is based on the assumption that prior to LambdaExpression.resolveType() we always see a call to setExpectedType().
In the light of JLS8 sect 18 this assumption is unfounded.

The interesting part will be this branch:
		if (!haveDescriptor && argumentsTypeElided) 
			return null; // FUBAR, bail out...

Making this work is the hardest part.
(In reply to comment #51)
> From my understanding of the code, all is based on the assumption that prior
> to LambdaExpression.resolveType() we always see a call to setExpectedType().
> In the light of JLS8 sect 18 this assumption is unfounded.
> 
> The interesting part will be this branch:
> 		if (!haveDescriptor && argumentsTypeElided) 
> 			return null; // FUBAR, bail out...
> 
> Making this work is the hardest part.

My original patch used a separate variable to track whether an expected type was "induced" properly, independent of the actual method binding.
I suppose we could use a sentinel value (MethodBinding.NO_METHOD) in a similar fashion?

One mitigating factor is that since we don't have a descriptor, the expression is in error anyway, and we wouldn't be able to verify return types or check parameter uses -- or am I missing something?
(In reply to comment #52)
> One mitigating factor is that since we don't have a descriptor, the
> expression is in error anyway, and we wouldn't be able to verify return
> types or check parameter uses -- or am I missing something?

Not in error. Here's an 'interesting' example from the spec:

  <T> T id(T arg) { return arg; }
  Runnable r = id(() -> { System.out.println("hi"); });

Not having a descriptor up-front is perfectly legal.
See also bug 400874.
(In reply to comment #51)
> From my understanding of the code, all is based on the assumption that prior
> to LambdaExpression.resolveType() we always see a call to setExpectedType().
> In the light of JLS8 sect 18 this assumption is unfounded.
> 
> The interesting part will be this branch:
> 		if (!haveDescriptor && argumentsTypeElided) 
> 			return null; // FUBAR, bail out...
> 
> Making this work is the hardest part.
 
Gentlemen, May I request you to hold your horses :) I appreciate the
energy levels ! 

Eventually, when a descriptor becomes available, every line of code in
this method is in need.

I am closing this bug shortly and action shifts to a different theater: 
bug 400871.

I expect to share a prototype solution that will address the concerns 
soon or if that gets delayed beyond a week to 10 days a sketch.
(In reply to comment #54)
> Eventually, when a descriptor becomes available, every line of code in
> this method is in need.

I'm not sure we will always have a descriptor *before* resolving the rest.
(In reply to comment #55)
> (In reply to comment #54)
> > Eventually, when a descriptor becomes available, every line of code in
> > this method is in need.
> 
> I'm not sure we will always have a descriptor *before* resolving the rest.

Here is a passage from the spec that is pertinent to the discussion we had
earlier today:

When the lambda parameters' types are inferred, the same lambda expression body can be interpreted in many different ways, depending on the context in which it appears. Specifically, the types of expressions in the body (including return statement values), the checked exceptions thrown, and the type-correctness of the code all depend on the formal parameters' inferred types.
There are two important implications. First, inference of parameter types must be independent of the lambda expression body (the alternative would be to do full constraint-producing type checking, which would be a lot more complex than the simple subtyping and conversion constraints that we handle now). Second, because lambda expressions can be method parameters, overload resolution may cause the same lambda body to be "hypothetically type-checked" more than onceâ€”that is, it may be type-checked multiple times, and an error that occurs during one of these times does not necessarily indicate that the program is incorrect.

I am putting in place the infrastructure to enable this analysis as part
of bug bug 400871.
(In reply to comment #56)

> Here is a passage from the spec that is pertinent to the discussion we had
> earlier today:

I'll say that the two sub passages are pointing in different directions, but
I expect to understand it better as I experiment a bit.

Here is the other interesting passage, I was referring to earlier:
 
A lambda expression (15.27) is potentially compatible with a functional interface type (9.8) if all of the following are true:
The arity of the functional interface's function descriptor is the same as the arity of the lambda expression.
If the functional interface's function descriptor has a void return, then the lambda body is either a statement expression (14.8) or a void-compatible block (15.27.2).
If the functional interface's function descriptor has (non-void) return type, then the lambda body is either an expression or a value-compatible block (15.27.2)

And

A block lambda body is value-compatible if it cannot complete normally (14.21) and every return statement in the block has the form return Expression;.

It is onerous to be able to determine the first part at the exact juncture
where it is required, while the latter can be trivially determined.

My present assessment is that it is a case of over-specification and we can 
punt on the first part about normal completion and the net effect would be
shifting of diagnostics - instead of overload resolution failing, resolution
of the block body would fail and no valid program would be rejected nor any
invalid program be accepted - Let us see.
(In reply to comment #56)

> My present assessment is that it is a case of over-specification and we can 
> punt on the first part about normal completion and the net effect would be
> shifting of diagnostics - instead of overload resolution failing, resolution
> of the block body would fail and no valid program would be rejected nor any
> invalid program be accepted - Let us see.

:)

15.12.2.5 states:

T is more specific than S for a lambda expression (15.27) if all of the following are true:
T and S are functional interface types
The functional interface named by T is neither a subinterface nor a superinterface of S
If the lambda expression's parameters have inferred types, then the descriptor parameter types of T are the same as the descriptor parameter types of S
Either i) the descriptor return type of S is void, or ii) for all result expressions in the lambda body (or for the body itself if the body is an expression), the descriptor return type of the capture of T is more specific than the descriptor return type of S

I'll had get back to coding and not answer bugzilla mails :)
Thanks for digging out those paragraphs.

I hadn't seen some of them because I expected (and still expect) to find 
them somewhere in section 18, which gives the impression that the general
constraint-solving approach *is* taken.

Maybe it's only the return type that participates in constraint solving
across nesting levels, not the parameter types. Maybe.

I promise to hold my horses until I hear an update from you :)
(In reply to comment #59)

> I promise to hold my horses until I hear an update from you :)

Or an SOS call :) 

Just kidding. (hope to be at least :))
All blocking bugs are resolved and this ER is ready to be resolved.

I did a quick scan of chapters A-E and we are essentially complete
with respect to these - We can now tackle head on the two tough 
nuts - F & G.

This is a major milestone - Thanks everyone !
(In reply to comment #51)
> From my understanding of the code, all is based on the assumption that prior
> to LambdaExpression.resolveType() we always see a call to setExpectedType().
> In the light of JLS8 sect 18 this assumption is unfounded.
> 
> The interesting part will be this branch:
> 		if (!haveDescriptor && argumentsTypeElided) 
> 			return null; // FUBAR, bail out...
> 
> Making this work is the hardest part.

I have carefully read through part F a coupe of times - I think this is 
actually fairly straightforward, even though at a first glance it looks 
hard.

I'll use bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=401610 to
showcase a sketch of how I plan to handle this problem. Stay tuned.
(In reply to comment #52)

> One mitigating factor is that since we don't have a descriptor, the
> expression is in error anyway, and we wouldn't be able to verify return
> types or check parameter uses -- or am I missing something?

(In reply to comment #55)
> (In reply to comment #54)
> > Eventually, when a descriptor becomes available, every line of code in
> > this method is in need.
> 
> I'm not sure we will always have a descriptor *before* resolving the rest.

The trick is to short circuit resolution when the descriptor is unavailable
and attempt it only later. Anyway since a patch is worth a thousand words,
I'll try to post one in a day or two.
(In reply to comment #54)
> (In reply to comment #51)
> > From my understanding of the code, all is based on the assumption that prior
> > to LambdaExpression.resolveType() we always see a call to setExpectedType().
> > In the light of JLS8 sect 18 this assumption is unfounded.
> > 
> > The interesting part will be this branch:
> > 		if (!haveDescriptor && argumentsTypeElided) 
> > 			return null; // FUBAR, bail out...
> > 
> > Making this work is the hardest part.

> I expect to share a prototype solution that will address the concerns 
> soon or if that gets delayed beyond a week to 10 days a sketch.

Please take a look at the patch posted at https://bugs.eclipse.org/bugs/show_bug.cgi?id=401610#c1 for hints as to
how I plan to solve this problem.

Excluding tests, it is ~370 lines of patch file diff text, a lot of it boiler
plate variety.
(In reply to comment #53)
> (In reply to comment #52)
> > One mitigating factor is that since we don't have a descriptor, the
> > expression is in error anyway, and we wouldn't be able to verify return
> > types or check parameter uses -- or am I missing something?
> 
> Not in error. Here's an 'interesting' example from the spec:
> 
>   <T> T id(T arg) { return arg; }
>   Runnable r = id(() -> { System.out.println("hi"); });
> 
> Not having a descriptor up-front is perfectly legal.

This works now and has been added as test case NegativeLambdaExpressionsTest.test401610d().

From 15.12.2.1:

"A lambda expression, a method reference, or a constructor reference is potentially compatible with a type variable if the type variable is a type parameter of the candidate method."

I think this should actually say, "is potentially compatible with any
type that mentions a type variable if the ..."
(In reply to Stephan Herrmann from comment #59)

> I promise to hold my horses until I hear an update from you :)

Just in case you are still holding your horses, please let the poor beasts
free, now that we are feature complete in the compiler thanks in huge measure
to your own contributions :)
(In reply to Srikanth Sankaran from comment #66)
> (In reply to Stephan Herrmann from comment #59)
> 
> > I promise to hold my horses until I hear an update from you :)
> 
> Just in case you are still holding your horses, please let the poor beasts
> free, now that we are feature complete in the compiler thanks in huge measure
> to your own contributions :)

No worries, the horses not only galloped criss-cross through type-inference-land but also grazed in neighbouring realms; they had all the exercise and nourishment they needed.

In the end having a complete spec in our hands did make a difference compared to what we had a year ago, wow ;-P

While reviewing bug 409586, follow-up items start to pile up.
Using this bug to collect and track those even though the original bug is not yet resolved so as to allow the main portion to be released soon.

From bug 409586 comment 65:
(1) NTAT#testBinary05 demonstrates that resetting contradictory nullTagBits is currently broken. Subsequently the non-null value is detected as not conforming to '@NonNull @Nullable Object'.

(2) ArrayBinding.nullAnnotatedReadableName(CompilerOptions, boolean) must use nullAnnotatedReadableName(..) also for its #leafComponentType, tests will need adjustments after that.

(3) FlowAnalysisTest8#testLambda_04 is now expecting one more error, which should be reverted. Should be a simple matter of clearing bogus nullAnnotationTagBits.

(4) Error messages in testBug416175()
1.: mixing short and long names
2.: I like "required \'@NonNull ? extends String\'" better than "required \'@NonNull capture#\'" when it's clear we're not interested in compatibility of the capture itself, only in null safety.

From bug 409586 comment 83:
(5) Investigate new locations throwing IllegalStateException to see if we can convince ourselves that these are "impossible to reach" :)


New items:
(6) delegating STB#getAnnotationTagBits() to this.prototype looks dangerous. Any client expecting this to show per-use null annotation tagbits will fail. Currently there appear to be no such clients, but ...

(7) Investigate: To challenge whether delegation to prototype is OK in STB#memberTypes(): will annotated reference to member type @TA Outer.Inner see its Outer as @TA (at the binding level)?

(8) STB#resolveTypeFor(FieldBinding): Invoking copySE8AnnotationsToType before field.fillInDefaultNonNullness is problematic because we'll use field.tagBits instead of field.type.tagBits!
'Accidentally' this is partly fixed by VariableBinding.isNonNull() where we check both tagBits locations. But bug shows when assigning null to such field:
  @NonNullByDefault class AllAreNonNull {
	String s3 = ""; // leaving this uninitialized would be detected
	void test() {
		this.s3 = null; // this goes unnoticed!!!
	}
  }
Note that the corresponding method resolveTypesFor(MethodBinding) does not have this issue, because INAV.checkImplicitNullAnnotations already distinguishes 1.7- vs. 1.8+ 

(9) MethodBinding#fillInDefaultNonNullness18 is currently broken. The following two simple changes seem to fix the respective TODOs:
  this.parameters[i] = env.createAnnotatedType(parameter, new AnnotationBinding[]{env.getNonNullAnnotation()});
  this.returnType = env.createAnnotatedType(this.returnType, new AnnotationBinding[]{env.getNonNullAnnotation()});
Seeing these as marked TODO could indicate there's more to this??

(10) BinaryTB#toString() needs update for instantiations similar to STB.

While reviewing bug 409586, follow-up items start to pile up.
Using this bug to collect and track those even though the original bug is not yet resolved so as to allow the main portion to be released soon.

From bug 409586 comment 65:
(1) NTAT#testBinary05 demonstrates that resetting contradictory nullTagBits is currently broken. Subsequently the non-null value is detected as not conforming to '@NonNull @Nullable Object'.

(2) ArrayBinding.nullAnnotatedReadableName(CompilerOptions, boolean) must use nullAnnotatedReadableName(..) also for its #leafComponentType, tests will need adjustments after that.

(3) FlowAnalysisTest8#testLambda_04 is now expecting one more error, which should be reverted. Should be a simple matter of clearing bogus nullAnnotationTagBits.

(4) Error messages in testBug416175()
1.: mixing short and long names
2.: I like "required \'@NonNull ? extends String\'" better than "required \'@NonNull capture#\'" when it's clear we're not interested in compatibility of the capture itself, only in null safety.

From bug 409586 comment 83:
(5) Investigate new locations throwing IllegalStateException to see if we can convince ourselves that these are "impossible to reach" :)


New items:
(6) delegating STB#getAnnotationTagBits() to this.prototype looks dangerous. Any client expecting this to show per-use null annotation tagbits will fail. Currently there appear to be no such clients, but ...

(7) Investigate: To challenge whether delegation to prototype is OK in STB#memberTypes(): will annotated reference to member type @TA Outer.Inner see its Outer as @TA (at the binding level)?

(8) STB#resolveTypeFor(FieldBinding): Invoking copySE8AnnotationsToType before field.fillInDefaultNonNullness is problematic because we'll use field.tagBits instead of field.type.tagBits!
'Accidentally' this is partly fixed by VariableBinding.isNonNull() where we check both tagBits locations. But bug shows when assigning null to such field:
  @NonNullByDefault class AllAreNonNull {
	String s3 = ""; // leaving this uninitialized would be detected
	void test() {
		this.s3 = null; // this goes unnoticed!!!
	}
  }
Note that the corresponding method resolveTypesFor(MethodBinding) does not have this issue, because INAV.checkImplicitNullAnnotations already distinguishes 1.7- vs. 1.8+ 

(9) MethodBinding#fillInDefaultNonNullness18 is currently broken. The following two simple changes seem to fix the respective TODOs:
  this.parameters[i] = env.createAnnotatedType(parameter, new AnnotationBinding[]{env.getNonNullAnnotation()});
  this.returnType = env.createAnnotatedType(this.returnType, new AnnotationBinding[]{env.getNonNullAnnotation()});
Seeing these as marked TODO could indicate there's more to this??

(10) BinaryTB#toString() needs update for instantiations similar to STB.
(11) Scope.substitute(Substitution,TypeBinding) isn't complete. To witness:
This example: 

  public class Substitute<T> {
	T foo(@NonNull List<@NonNull T> l) {
		return l.get(0);
	}	
	public static void main(String[] args) {
		Substitute<String> s = new Substitute<>();
		s.foo(new ArrayList<String>()); // (1)
		s.foo(null); // (2)
	}
  }
At (1) we get correctly warned that 'String' instead of '@NonNull String' requires unchecked conversion.

At (2) the compiler remains silent.

In the debugger the following situation seems to be the culprit:

Scope.substitute(Substitution, TypeBinding) line: 438	
Scope.substitute(Substitution, TypeBinding[]) line: 545	
ParameterizedMethodBinding.<init>(ParameterizedTypeBinding, MethodBinding) line: 121	
ParameterizedTypeBinding.createParameterizedMethod(MethodBinding) line: 362	
ParameterizedTypeBinding.getMethods(char[]) line: 668	
ParameterizedTypeBinding.getExactMethod(char[], TypeBinding[], CompilationUnitScope) line: 579	
MethodScope(Scope).findExactMethod(ReferenceBinding, char[], TypeBinding[], InvocationSite) line: 1100	
MethodScope(Scope).getMethod(TypeBinding, char[], TypeBinding[], InvocationSite) line: 2499	
MessageSend.resolveType(BlockScope) line: 680	

While merging the original '@NonNull List<@NonNull T>' with the substitution T->String we lose the outer @NonNull.

Prior to bug 409586 I had a method copyAnnotations to re-apply all annotations that might get lost during substitution. This approach could handle the above example, not sure if it would fail at more involved scenarii, though.

We need to decide whether
(a) we continue adding individual calls to createAnnotatedType() into details of Scope.substitute(..), or if
(b) restoring the general wrapping via copyAnnotations() is better.

@Srikanth: any hidden reasons why you removed LE#copyAnnotations() and its use in Scope?
(12) NTAT#testConditional1 shows one fewer warnings, and a TODO links to another TODO in Scope#lowerUpperBound.
Failure to report the warning in question can be traced back to removal of these lines in ConditionalExpression#resolveType():

  if (use18specifics && valueIfTrueType != null && valueIfFalseType != null && valueIfTrueType != valueIfFalseType) {
	valueIfTrueType = valueIfTrueType.unannotated();
	valueIfFalseType = valueIfFalseType.unannotated();
  }

In order to follow the suggested road, I'd need to understand why handling this issue inside lub() is better than hiding type annotations from lub computation.

When re-inserting the deleted lines we may have to check if it requires some re-applying of dropped annotations so this.resolvedType won't lose necessary information. Maybe that's why those lines were deleted? OTOH, I'm afraid that letting lub() handle this might have unwanted effects during type inference?
(13) We spoke about making the deep encoding configurable, so clients not interested in type annotations could avoid this overhead.
Should this road be followed one fairly central spot to check for that switch would be inside BinaryTB where we create the TypeAnnotationWalker. If no annotations are requested the EMPTY_ANNOTATION_WALKER will do.

For STB ASTNode#copySE8AnnotationsToType could kill a few birds.
(14) BinaryTB#scanFieldForNullAnnotation had an initial stanza which served two purposes for the 1.8+ case:
- apply a @NonNullByDefault to the field's type binding
- shortcut everything else that is needed only for 1.7-

Frankly, I don't understand this change.
The first aspect may partly be covered by VariableBinding#isNonNull() which checks tagBits at the FieldBinding AND at its type, but this is probably not sufficient/safe.
Created attachment 235470
Latest patch - with better documentation.

I am part way through the self review. I will continue to comment the code
where it is called for and repost. I don't expect to make any fixes other
than commenting and clean up in this pass.
Some comments on review comments: Those not responded to - need more investigation.

(In reply to Stephan Herrmann from comment #0)
> While reviewing bug 409586, follow-up items start to pile up.
> Using this bug to collect and track those even though the original bug is
> not yet resolved so as to allow the main portion to be released soon.
> 
> From bug 409586 comment 65:
> (1) NTAT#testBinary05 demonstrates that resetting contradictory nullTagBits
> is currently broken. Subsequently the non-null value is detected as not
> conforming to '@NonNull @Nullable Object'.

> (2) ArrayBinding.nullAnnotatedReadableName(CompilerOptions, boolean) must
> use nullAnnotatedReadableName(..) also for its #leafComponentType, tests
> will need adjustments after that.
> 
> (3) FlowAnalysisTest8#testLambda_04 is now expecting one more error, which
> should be reverted. Should be a simple matter of clearing bogus
> nullAnnotationTagBits.
> 
> (4) Error messages in testBug416175()
> 1.: mixing short and long names
> 2.: I like "required \'@NonNull ? extends String\'" better than "required
> \'@NonNull capture#\'" when it's clear we're not interested in compatibility
> of the capture itself, only in null safety.

(1) - (4): Agreed. Let us address this in a follow up patch.

> New items:
> (6) delegating STB#getAnnotationTagBits() to this.prototype looks dangerous.
> Any client expecting this to show per-use null annotation tagbits will fail.
> Currently there appear to be no such clients, but ...

I think we should simply document that getAnnotationTagBits() returns the
bits corresponding to the declaration binding. 

> (9) MethodBinding#fillInDefaultNonNullness18 is currently broken. The
> following two simple changes seem to fix the respective TODOs:
>   this.parameters[i] = env.createAnnotatedType(parameter, new
> AnnotationBinding[]{env.getNonNullAnnotation()});
>   this.returnType = env.createAnnotatedType(this.returnType, new
> AnnotationBinding[]{env.getNonNullAnnotation()});
> Seeing these as marked TODO could indicate there's more to this??

I think that should be it. I was not aware of env.getNonNullAnnotation()'s
existence. 

> (10) BinaryTB#toString() needs update for instantiations similar to STB.

yes and likely a few others too.

(In reply to Stephan Herrmann from comment #3)
> (13) We spoke about making the deep encoding configurable, so clients not
> interested in type annotations could avoid this overhead.
> Should this road be followed one fairly central spot to check for that
> switch would be inside BinaryTB where we create the TypeAnnotationWalker. If
> no annotations are requested the EMPTY_ANNOTATION_WALKER will do.

My plan was that LE would operate in terms of abstract TypeSystem and
instantiate either UTS or ATS based of ProcessAnnotations and isAnnotation*NullAnalysis* option.


(In reply to Stephan Herrmann from comment #4)
> (14) BinaryTB#scanFieldForNullAnnotation had an initial stanza which served
> two purposes for the 1.8+ case:
> - apply a @NonNullByDefault to the field's type binding
> - shortcut everything else that is needed only for 1.7-

Sorry. I may have been guilty of over-pruning here and a few other places.
We will address this post release of the initial infrastructure.
Created attachment 235484
Proposed patch

I have avoided fixing anything - only cleanups to improve readability and
comments have been incorporated.

I have finished one round of self review - I plan to review the entire TypeBinding hierarchy all over again.
(In reply to Stephan Herrmann from comment #0)

> (7) Investigate: To challenge whether delegation to prototype is OK in
> STB#memberTypes(): will annotated reference to member type @TA Outer.Inner
> see its Outer as @TA (at the binding level)?

Good point. I'll add a 15th follow up item:

(15) Review the entire TypeBinding hierarchy. In particular see if delegation
to prototype where it happens is appropriate. Where it does not happen, why
and should there be some asserts ?
(16) It should be clarified for all ATS#get*Type() methods, whether the primary input type can already be annotated. Only getParameterizedType() strips off any 'misplacedAnnotations', all others take the input type as-is (with a note that getRaw/WildcardType might need the same treatment). 
Indication for expecting annotated input types: each of these methods uses haveTypeAnnotations(..) which checks the input type (and the explicit annotations). 
Indication for not expecting annotated input types: Input type is directly used as the key in this.annotatedTypes.get(type), which otherwise *appears* to be a mapping from unadorned types to types with any of {dimensions|parameters|annotations}*.

I see two possible outcomes of this clarification:

Yes: intention is that input types (except for getParameterizedType()) should be unannotated. -> This should be documented and checked per client. In this case checking the input type in haveTypeAnnotations is redundant.

No: it is not practical to require all clients to ensure that the input type is unannotated. -> These methods should perhaps adopt the scheme of handling misplacedAnnotations as done in getParameterizedType() or some variant thereof.

Witness against "Yes": NTAT#testArrayType_01 triggers ATS#getArrayType with a leafType of "@NonNull String" (BinaryTB).
(17)

(In reply to bug 409586 comment 83)
> - the same method has a AnnotationBinding[][] parameter, what's the meaning
>  of these array dimensions?

This is much clearer now for QTR and PQTR (and AR), but what about QAR?
How are annotations collected for
  @A1 Outer.@A2 Inner @A3[]@A4 @A5[]
?

Experiments indicate we seem to be losing @A1 in this case. Not sure where exactly this happens.
(18) I could use a little hint to see why this ISE is never raised in UTS:
  TypeBinding getUnannotatedType(TypeBinding type) {
	if (type.id == TypeIds.NoId) {
		if (type.hasTypeAnnotations() && !type.isTypeVariable())
			throw new IllegalStateException();
(In reply to Stephan Herrmann from comment #9)
> (16) It should be clarified for all ATS#get*Type() methods, whether the
> primary input type can already be annotated. Only getParameterizedType()
> strips off any 'misplacedAnnotations', all others take the input type as-is
> (with a note that getRaw/WildcardType might need the same treatment).

By primary I presume, you mean the key to the SLT.

In RTB, PTB and WB, we don't expect the generic type to come in annotations.
If it does it is considered "misplaced" and for consistent treatment with 
type references in source code, the annotations should be moved to the 
annotations parameter.

For arrays, the left component type could come in annotated. We don't
consider that misplaced again by how things get constructed for source type
references.

When we see 

    @NonNull String @Nullable[],

at the time the array binding is created, the leaf component type is
already "reduced" and annotated. So when we annotate the array dimension
with @Nullable, the leaf component type comes in as annotated.
  
> Indication for expecting annotated input types: each of these methods uses
> haveTypeAnnotations(..) which checks the input type (and the explicit
> annotations). 

In the ATS#get* methods, various component types that form the composite type
that is being "gotten", could come in with annotations, i.e leaf component
type, enclosing type, type arguments etc. If none of these have annotations
then ATS leaves it entirely to UTS to track the composite type. 
 
> Indication for not expecting annotated input types: Input type is directly
> used as the key in this.annotatedTypes.get(type), which otherwise *appears*
> to be a mapping from unadorned types to types with any of
> {dimensions|parameters|annotations}*.

The key to the this.annotatedTypes.get method call is one of: leaf component
type (arrays) or the generic type (RTB, PTB, WB): In the former case, it
could be annotated. In the latter cases, by construction of how source type
references get handled, we don't expect the generic type to come in annotated.
For the annotations on types read from class files, generic type could come
in annotated, we consider that misplaced and reattribute it - this last part
is not done yet for RTB and WB as the comment calls out. We should do.

By design, when we retrieve a type from ATS.annotatedTypes, we compare the
cachedType against possibly annotated components (type arguments, enclosing
type etc) to ensure identity only when all annotated components match.

> Witness against "Yes": NTAT#testArrayType_01 triggers ATS#getArrayType with
> a leafType of "@NonNull String" (BinaryTB).

In ATS.annotatedTypes, @NonNull String would have its own cached TypeBinding[]
(in which @NonNull String [], @NonNull String @NonNull[], @NonNull String [][][]
etc would sit) while say @Interned String would get its own cached TypeBinding[]

(In reply to Stephan Herrmann from comment #10)
> (17)
> 
> (In reply to bug 409586 comment 83)
> > - the same method has a AnnotationBinding[][] parameter, what's the meaning
> >  of these array dimensions?
> 
> This is much clearer now for QTR and PQTR (and AR), but what about QAR?
> How are annotations collected for
>   @A1 Outer.@A2 Inner @A3[]@A4 @A5[]

There is a bug here, but not probably what you think. Is this example type 
reference the type of a field, local, parameter etc ? If so, first @A1 would
annotate the declared entity and then get transferred to the type in a separate
step.

However, there is a bug here: in that after copySE8*() method runs we end
up with @A1 Outer.Inner @A3[]@A4 @A5[] i.e @A2 is dropped. That is due to
a bad assumption on my part that we will only ever clone the unannotated
type and specialize it with enclosing type, type arguments and annotations.
We need to in this case clone the already annotated @A2 Inner and bestow it
with an annotated enclosing type @A1 Outer. The fix should be simple. Since
this is something I view as critical, I'll incorporate it and post a patch
and not defer this to later.

I also apologize that various toString() methods are not in place, leading
to a confusing debugging experience, will fix this too.

(In reply to Stephan Herrmann from comment #11)

> (18) I could use a little hint to see why this ISE is never raised in UTS:
>   TypeBinding getUnannotatedType(TypeBinding type) {
> 	if (type.id == TypeIds.NoId) {
> 		if (type.hasTypeAnnotations() && !type.isTypeVariable())
> 			throw new IllegalStateException();

If a type is annotated at all, UTS must have ID stamped it by design. The one
exception is TVB, where I am directly calling setAnnotations from within
TypeParameter code - I don't think we should have this special treatment
and will get rid of it.

I believe all design clarification questions raised so far have been answered,
only various issues raised that are not questions/clarifications in nature
have been deferred to a follow up patch. Let me know if I have overlooked
some clarification for request.
(In reply to Srikanth Sankaran from comment #12)

> I also apologize that various toString() methods are not in place, leading
> to a confusing debugging experience, will fix this too.

At the moment, I try to view the typeAnnotations field of the TypeBinding
to see what it carries. This is a productivity drain and the toString methods
should do fixed, but if you are debugging right now, you can use this as
a stop gap and not trust the toString() output you see. Again sorry about
that.
Created attachment 235492
Proposed patch

This patch contains the following additional changes:

1. PSTR: Annotations were being resolved rather eagerly, Deferred it till
array creation is handled for the case PSTR's super ATR actually has dimensions.

2. ATS: Clone operation was incorrectly invoked on the unannotated type
resulting in loss of annotations in "@A1 X.@A2 Y xy;"

3. Customized toString() output to include type annotations for all TypeBinding's

(3) Should have been done right at day 1. Sorry.
(In reply to Srikanth Sankaran from comment #14)

> 2. ATS: Clone operation was incorrectly invoked on the unannotated type
> resulting in loss of annotations in "@A1 X.@A2 Y xy;"

(19) Does clone operation need type arguments to be tunneled to it. I doubt
it. We may be able to get rid of it.
Using this example: 

class Outer {
	class Inner {}
	@A1 Outer.@A2 Inner @A3[]@A4 @A5[] x = (@A1 Outer.@A2 Inner @A3[]@A4 @A5[]) null; 
	java.util.@A1 Map<@A2 String, @A3 Integer> @A4[] @A5[] y = (java.util.@A1 Map<@A2 String, @A3 Integer> @A4[] @A5[]) null; 
} 

For the latter field initialization, bindings are the same for field type and
initialization type. In the former field initialization, they are unequal
but id set to equal. (There is a clone of a clone involved in the former case,
as an interesting side effect of the present implementation (how it copies
annotations from se7 locations - this may be avoidable.)

I'll also get full coverage tests get written for this task before resolving
this bug, but post the initial patch release.
(In reply to Srikanth Sankaran from comment #12)
> (In reply to Stephan Herrmann from comment #9)
> > (16) It should be clarified for all ATS#get*Type() methods, whether the
> > primary input type can already be annotated. Only getParameterizedType()
> > strips off any 'misplacedAnnotations', all others take the input type as-is
> > (with a note that getRaw/WildcardType might need the same treatment).
> 
> By primary I presume, you mean the key to the SLT.

right 

> For arrays, the left component type could come in annotated. We don't
> consider that misplaced again by how things get constructed for source type
> references.
> 
> When we see 
> 
>     @NonNull String @Nullable[],
> 
> at the time the array binding is created, the leaf component type is
> already "reduced" and annotated. So when we annotate the array dimension
> with @Nullable, the leaf component type comes in as annotated.

Glad I asked, because I guessed that that SLT would apply the same rule for any kind of adornment. But from what you write I learned that different strategies are used for AB vs. PTB etc. Fair enough.
(In reply to Srikanth Sankaran from comment #12)
> I believe all design clarification questions raised so far have been
> answered,

I agree.

Most clarification can already be found in code comments.

Some aspects regarding how annotated array types are created have been 
explained here in this bug. Perhaps some of this deserves being cast into
additional code comments, notably, the fact that several methods in ATS do
*not* handle annotations of the leaf type (getArrayType(..) and
getAnnotatedType(TypeBinding,AnnotationBinding[][]), i.e., annotations on
the leaf type must already be applied prior to calling one of these methods.
(In reply to Srikanth Sankaran from comment #12)
> (In reply to Stephan Herrmann from comment #10)
> > How are annotations collected for
> >   @A1 Outer.@A2 Inner @A3[]@A4 @A5[]
> 
> There is a bug here, but not probably what you think. Is this example type 
> reference the type of a field, local, parameter etc ? If so, first @A1 would
> annotate the declared entity and then get transferred to the type in a
> separate
> step.
> 
> However, there is a bug here: in that after copySE8*() method runs we end
> up with @A1 Outer.Inner @A3[]@A4 @A5[] i.e @A2 is dropped. That is due to
> a bad assumption on my part that we will only ever clone the unannotated
> type and specialize it with enclosing type, type arguments and annotations.
> We need to in this case clone the already annotated @A2 Inner and bestow it
> with an annotated enclosing type @A1 Outer. The fix should be simple. Since
> this is something I view as critical, I'll incorporate it and post a patch
> and not defer this to later.

Good, my example now works.

Somehow I was expecting getAnnotatedType(TypeBinding,AnnotationBinding[][]) to do more at once, but now I can see that the binding is annotated in 3 steps (capturing my observations for future reference):
- add top-level type annotations
  getAnnotatedType(Outer.Inner, [[][@A2]])
  -> Outer.@A2 Inner
- from this leaf type create the array and then apply annotations on dims:
  getAnnotatedType(Outer.@A2 Inner, [[@A3][@A4,@A5]])
  -> Outer.@A2 Inner @A3[] @A4 A5[]
- to this type add the annotation misplaced as a declaration annotation
  getAnnotatedType(Outer.@A2 Inner @A3[] @A4 A5[], [[@A1][]])
  -> @A1 Outer.@A2 Inner @A3[] @A4 A5[]

This looks complicated, but apparently we cannot avoid this complexity, because the last step can indeed only be made in the context of a declaration, whereas the former steps are driven by the type reference itself.
(20) An optional cosmetic suggestion:
In ASTNode#copySE8AnnotationsToType() repetitious code can be extracted to a
new method, to yield paragraphs along these lines:
  case Binding.LOCAL:
      LocalVariableBinding local = (LocalVariableBinding) recipient;
      TypeReference typeRef = local.declaration.type;
      if (Annotation.isTypeUseCompatible(typeRef, scope)) {
          local.declaration.bits |= HasTypeAnnotations;
          local.type = copyIntoType(scope.environment(), se8Annotations, typeRef, local.type);
      }
      break;
(In reply to Stephan Herrmann from comment #0)
> (1) NTAT#testBinary05 demonstrates that resetting contradictory nullTagBits
> is currently broken. Subsequently the non-null value is detected as not
> conforming to '@NonNull @Nullable Object'.

This seems to be caused by the following change:
In HEAD Annotation#resolveType(..) has one more line (removed in the patch):
  variable.type = scope.environment().createAnnotatedType(variable.type, nullTagBits);
This business is now done later in TypeBinding#setTypeAnnotations(..).

As a consequence we are now resetting the type to unannotated *before* the
annotated type has been created :)

BTW: should we extract the null-related items into a new bug (assigned to me)?
In my review I still want to do a final walk through the changes in package lookup. But from all I've seen there's nothing blocking the release of the latest patch.

In terms of criticality I'd vote up the issue of Scope.substitute (item (11)). If indeed we want to make substitute() deeply aware of annotations, too, that could become a little project of its own. I don't doubt this to be feasible, though.
(In reply to Stephan Herrmann from comment #22)
> In my review I still want to do a final walk through the changes in package
> lookup. But from all I've seen there's nothing blocking the release of the
> latest patch.

Thanks, I have released it here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=3b7e9a0f1d7c1bcba3808ca366020fd264fda3dd

(In reply to Stephan Herrmann from comment #21)

> BTW: should we extract the null-related items into a new bug (assigned to
> me)?

Thanks much for the offer. I'll open a fresh follow up bug and transfer the
related tasks there. Also post an up to date follow up tasks for the present
bug here shortly.
Reviewing pending tasks for the current CR:

(In reply to Stephan Herrmann from comment #0)

> From bug 409586 comment 83:
> (5) Investigate new locations throwing IllegalStateException to see if we
> can convince ourselves that these are "impossible to reach" :)

I have cleaned up a few places already. What remains should be valid ones,
We will know :) I'll treat this as closed.

> (10) BinaryTB#toString() needs update for instantiations similar to STB.

This is already done and released.

(In reply to Stephan Herrmann from comment #10)
> (17)
> 
> (In reply to bug 409586 comment 83)
> > - the same method has a AnnotationBinding[][] parameter, what's the meaning
> >  of these array dimensions?
> 
> This is much clearer now for QTR and PQTR (and AR), but what about QAR?
> How are annotations collected for
>   @A1 Outer.@A2 Inner @A3[]@A4 @A5[]
> ?
> 
> Experiments indicate we seem to be losing @A1 in this case. Not sure where
> exactly this happens.

This is closed.

(In reply to Stephan Herrmann from comment #11)
> (18) I could use a little hint to see why this ISE is never raised in UTS:
>   TypeBinding getUnannotatedType(TypeBinding type) {
> 	if (type.id == TypeIds.NoId) {
> 		if (type.hasTypeAnnotations() && !type.isTypeVariable())
> 			throw new IllegalStateException();

This is closed. I'll probably clean up the treatment for TVB.

I'll carry over the rest and renumber them shortly.
Pending tasks:

(1) Another round of close scrutiny of the entire TypeBinding hierarchy.
In particular, where we store a prototype and delegate to it, make sure
the delegation makes sense. We already know of one instance STB#memberTypes
where it may not. In every type that stores a prototype, inspect all non-static
non-private methods to see (a) if delegation is called for and is in place
(b) delegation is not called, but is incorrectly in place (c) where it guaranteed
that a certain method would be invoked only on the declaration binding, insert
an assert of sorts.

(2) Replace != and == with suitable wrappers.

(3) delegating STB#getAnnotationTagBits() to this.prototype looks dangerous. Any client expecting this to show per-use null annotation tagbits will fail. Currently there appear to be no such clients, but ...

[We should document this away]

(4) Scope.substitute(Substitution,TypeBinding) isn't complete. To witness:
This example: 

  public class Substitute<T> {
	T foo(@NonNull List<@NonNull T> l) {
		return l.get(0);
	}	
	public static void main(String[] args) {
		Substitute<String> s = new Substitute<>();
		s.foo(new ArrayList<String>()); // (1)
		s.foo(null); // (2)
	}
  }
At (1) we get correctly warned that 'String' instead of '@NonNull String' requires unchecked conversion.

At (2) the compiler remains silent.

[Entire TVB handling needs a relook. At the time clone is called, the
prototype's instance fields are not initialized and we end up cloning
them]

(5) NTAT#testConditional1 shows one fewer warnings, and a TODO links to another TODO in Scope#lowerUpperBound.
Failure to report the warning in question can be traced back to removal of these lines in ConditionalExpression#resolveType():

  if (use18specifics && valueIfTrueType != null && valueIfFalseType != null && valueIfTrueType != valueIfFalseType) {
	valueIfTrueType = valueIfTrueType.unannotated();
	valueIfFalseType = valueIfFalseType.unannotated();
  }

In order to follow the suggested road, I'd need to understand why handling this issue inside lub() is better than hiding type annotations from lub computation.

When re-inserting the deleted lines we may have to check if it requires some re-applying of dropped annotations so this.resolvedType won't lose necessary information. Maybe that's why those lines were deleted? OTOH, I'm afraid that letting lub() handle this might have unwanted effects during type inference?

(6)  We spoke about making the deep encoding configurable, so clients not interested in type annotations could avoid this overhead.
Should this road be followed one fairly central spot to check for that switch would be inside BinaryTB where we create the TypeAnnotationWalker. If no annotations are requested the EMPTY_ANNOTATION_WALKER will do.

(7) It should be clarified for all ATS#get*Type() methods, whether the primary input type can already be annotated.

[Also for other arguments, will do]

(8) Does clone operation need type arguments to be tunneled to it. I doubt
it. We may be able to get rid of it.

(9)  An optional cosmetic suggestion:
In ASTNode#copySE8AnnotationsToType() repetitious code can be extracted to a
new method, to yield paragraphs along these lines:
  case Binding.LOCAL:
      LocalVariableBinding local = (LocalVariableBinding) recipient;
      TypeReference typeRef = local.declaration.type;
      if (Annotation.isTypeUseCompatible(typeRef, scope)) {
          local.declaration.bits |= HasTypeAnnotations;
          local.type = copyIntoType(scope.environment(), se8Annotations, typeRef, local.type);
      }
      break;

(10) Verify that annotated type binding uniqueness actually kicks in
for marker annotated types. For others, we don't guarantee this. Perhaps
we could extend this for single member annotations with default values,
but this may not be worth it.

[See comment#16]

(11) Address the sole failure. I think TVB should cache the prototype
and deflect - this is probably the reason for the failure in the disabled
test GrammarCoverageTests308._test023()

(12) Make sure all TypeBinding classes implement copy constructors properly,
in some of them clone directly does the work. For consistency we should
change to one style.

( Full coverage tests, but this will happen in the context of DOM
bindings (https://bugs.eclipse.org/bugs/show_bug.cgi?id=409586))
Srikanth, BaseTypeBinding.unannotated() doesn't include 'void'. Is this intentional? This is causing problem when unannotated() is called on a 'void' binding, such as the return type of a void method.
(In reply to Jayaprakash Arthanareeswaran from comment #26)
> Srikanth, BaseTypeBinding.unannotated() doesn't include 'void'. Is this
> intentional? This is causing problem when unannotated() is called on a
> 'void' binding, such as the return type of a void method.

I guess you are asking for this for uniform treatment rather than because
we have somehow allowed a program to type annotate a void method's return 
type.

Fix here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=4ddbf9298dc613dd5b5aca8c1b39fe7b57d91f28
Continuing comment#25, pending tasks: 

(13) Presently, wild card capture captures the unannotated wildcard and
then annotates the capture. In the process we lose the annotations on the
wildcard's bounds. Need to figure out what is the right thing here.

(14) LTB#clone reads:

	LocalTypeBinding copy = new LocalTypeBinding(this);
	if (outerType == null) {
		outerType = enclosingType();
	}
	return copy;

This is most certainly wrong, cf MTB#clone.

(15) LE#getTypeFromSignature: We are dropping annotations on enclosing types.
There is a comment to that effect in code.

(16) Re-review all overrides of Substitution.substitute(TypeVariableBinding)
(17) Running NullAnnotationTest in 1.8 mode I see 1 error and 49 failures. The error is an NPE in ASTNode.copySE8AnnotationsToType due to a null within the annotations array. Is it safe to just skip nulls here?
Some failures could be caused by missing implementation in MethodBinding.fillInDefaultNonNullness18(..). I'll check that part and will report back here.
(In reply to Stephan Herrmann from comment #29)
> (17) Running NullAnnotationTest in 1.8 mode I see 1 error and 49 failures.
> The error is an NPE in ASTNode.copySE8AnnotationsToType due to a null within
> the annotations array. Is it safe to just skip nulls here?
> Some failures could be caused by missing implementation in
> MethodBinding.fillInDefaultNonNullness18(..). I'll check that part and will
> report back here.

With the fix in MethodBinding.fillInDefaultNonNullness18(..) we'll be down at 1 error plus 28 failures.
(In reply to Srikanth Sankaran from comment #25)
> (2) Replace != and == with suitable wrappers.

Commit 25c55f5a3b95044fb71ce56ee0bb0a797b58daa1 on behalf of bug 417295 comment 6 has some changes in this regard inside Expression.checkCastTypesCompatibility(..).
(In reply to Stephan Herrmann from comment #29)
> (17) Running NullAnnotationTest in 1.8 mode I see 1 error and 49 failures.
> The error is an NPE in ASTNode.copySE8AnnotationsToType due to a null within
> the annotations array. Is it safe to just skip nulls here?
> Some failures could be caused by missing implementation in
> MethodBinding.fillInDefaultNonNullness18(..). I'll check that part and will
> report back here.

I should've noted that in regression.TestAll these tests are currently disabled.
Except for the NPE in ASTNode.copySE8AnnotationsToType I will look at these failures via bug 417295.
In bug 417295 I had to make changes to ASTNode.copySE8AnnotationsToType anyway, so I addressed item (9) and the NPE from (17) via that bug.
(In reply to Stephan Herrmann from comment #29)
> (17) Running NullAnnotationTest in 1.8 mode I see 1 error and 49 failures.

When you run All JDT/Core tests does this get run at 1.8 ? I ran all the tests
not Java8 and it was all green ? So puzzled about these failures you report.
The following produces an NPE. Should I report a new bug?

package p;
public class X <@Marker T extends @Marker Y<@Marker ?>, @Marker Q extends @Marker Integer> {
}
@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)
@interface Marker {}

This is the same test case from GrammarCoverageTests308#test022(), but occurs only when we are trying to resolve binding, I guess.
(In reply to Srikanth Sankaran from comment #34)
> (In reply to Stephan Herrmann from comment #29)
> > (17) Running NullAnnotationTest in 1.8 mode I see 1 error and 49 failures.
> 
> When you run All JDT/Core tests does this get run at 1.8 ? I ran all the
> tests
> not Java8 and it was all green ? So puzzled about these failures you report.

This was my bad: I had disabled NAT a while ago, forgot to re-enable when they
were green again (forgot because they were always the first I directly ran).

I'll make sure that after fixing these failures I will enable that suite :)
(In reply to Jayaprakash Arthanareeswaran from comment #35)
> The following produces an NPE. Should I report a new bug?
> 
> package p;
> public class X <@Marker T extends @Marker Y<@Marker ?>, @Marker Q extends
> @Marker Integer> {
> }
> @java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)
> @interface Marker {}
> 
> This is the same test case from GrammarCoverageTests308#test022(), but
> occurs only when we are trying to resolve binding, I guess.

Basically TVB handling has a bunch of unresolved issues. I'll add a test 
for this when before resolving it.
(In reply to Srikanth Sankaran from comment #25)
> Pending tasks:

> (3) delegating STB#getAnnotationTagBits() to this.prototype looks dangerous.
> Any client expecting this to show per-use null annotation tagbits will fail.
> Currently there appear to be no such clients, but ...
> 
> [We should document this away]

> (8) Does clone operation need type arguments to be tunneled to it. I doubt
> it. We may be able to get rid of it.


> (14) LTB#clone reads:
> 
> 	LocalTypeBinding copy = new LocalTypeBinding(this);
> 	if (outerType == null) {
> 		outerType = enclosingType();
> 	}
> 	return copy;
> 
> This is most certainly wrong, cf MTB#clone.

These are covered by http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=d81f79f00816b88315f5cebda6e215147f9e97f8
(In reply to Srikanth Sankaran from comment #25)

> (4) Scope.substitute(Substitution,TypeBinding) isn't complete. To witness:
> This example: 
> 
>   public class Substitute<T> {
> 	T foo(@NonNull List<@NonNull T> l) {
> 		return l.get(0);
> 	}	
> 	public static void main(String[] args) {
> 		Substitute<String> s = new Substitute<>();
> 		s.foo(new ArrayList<String>()); // (1)
> 		s.foo(null); // (2)
> 	}
>   }
> At (1) we get correctly warned that 'String' instead of '@NonNull String'
> requires unchecked conversion.
> 
> At (2) the compiler remains silent.

Thanks for catching this, this is a gross oversight on my part, Fixed via:
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=a97d6cfe4321b5c45bce6a9e682825ee765b8f5b
(In reply to Srikanth Sankaran from comment #12)
> > Indication for not expecting annotated input types: Input type is directly
> > used as the key in this.annotatedTypes.get(type), which otherwise *appears*
> > to be a mapping from unadorned types to types with any of
> > {dimensions|parameters|annotations}*.
> 
> The key to the this.annotatedTypes.get method call is one of: leaf component
> type (arrays) or the generic type (RTB, PTB, WB): In the former case, it
> could be annotated. In the latter cases, by construction of how source type
> references get handled, we don't expect the generic type to come in
> annotated.

While experimenting with type annotations during lub computation I needed a method to re-annotated an existing type with a new set of annotations (intersection of several sets), in which case I need to discard existing toplevel annotations but I need to keep all type annotations at details (type parameters ...) unchanged.

It seems that this isn't supported by either overload of LE#createAnnotatedType, because it violates your assumption.

It appears the following could fix my problem:
Inside
   AnnotatableTypeSystem.getAnnotatedType(TypeBinding, AnnotationBinding[][]) 
change the inner call
  annotatedType = getAnnotatedType(types[j], enclosingType, types[j].typeArguments(), annotations[i]);
to
  annotatedType = getAnnotatedType(types[j].unannotated(), enclosingType, types[j].typeArguments(), annotations[i]);
                                           ^^^^^^^^^^^^^^

Or perhaps this change could even pushed into the second method.

Do you think this would break anything?
(In reply to Stephan Herrmann from comment #40)
> Do you think this would break anything?

Yes it does. :(

In NTAT#test_nestedType_04 we'd no longer create correct annotations into

  A<Object>.@Nullable I<@NonNull String> ai

Do you have a suggestion for an API that *replaces* toplevel annotations while leaving details unchanged?
(In reply to Stephan Herrmann from comment #41)

> Do you have a suggestion for an API that *replaces* toplevel annotations
> while leaving details unchanged?

Take a look at LookupEnvironment.createAnnotatedType(TypeBinding, AnnotationBinding[])

This doesn't do what you want quite, but by adding a third boolean parameter
we can ask it to replace rather than merge new annotations with existing ones.
Would that work for you ?
(In reply to Srikanth Sankaran from comment #42)
> (In reply to Stephan Herrmann from comment #41)
> 
> > Do you have a suggestion for an API that *replaces* toplevel annotations
> > while leaving details unchanged?
> 
> Take a look at LookupEnvironment.createAnnotatedType(TypeBinding,
> AnnotationBinding[])
> 
> This doesn't do what you want quite, but by adding a third boolean parameter
> we can ask it to replace rather than merge new annotations with existing
> ones.
> Would that work for you ?

Looks related indeed, but I believe even that existing method has a problem, because it causes the half-annotated type to be used as the key for ATS#annotatedTypes, doesn't it? 
That'd mean we can easily create duplicates of equal annotated types, because the same naked type will have annotated types in different slots of #annotatedTypes.


We may get away with just adding an "unannotated()" into the first line of AnnotatableTypeSystem.getAnnotatedType(TypeBinding, TypeBinding, TypeBinding[], AnnotationBinding[]) :

	TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(type.unannotated());

That way we'd be sure to always use the correct key and thus avoid duplication of equal annotated types.
(In reply to Stephan Herrmann from comment #43)

> Looks related indeed, but I believe even that existing method has a problem,
> because it causes the half-annotated type to be used as the key for
> ATS#annotatedTypes, doesn't it? 
> That'd mean we can easily create duplicates of equal annotated types,
> because the same naked type will have annotated types in different slots of
> #annotatedTypes.

By reaching there with say [T1 .. T3] + [T4 ... T5] and alternately say by
[T1 .. T2] + [T3 .. T5] where the first of each pairs is the "oldies" 
and the second of each pairs is the "newbies".
 
Plausible. This should not create a correctness issue, only wasted memory.

> We may get away with just adding an "unannotated()" into the first line of
> AnnotatableTypeSystem.getAnnotatedType(TypeBinding, TypeBinding,
> TypeBinding[], AnnotationBinding[]) :
> 
> 	TypeBinding[] cachedInfo = (TypeBinding[])
> this.annotatedTypes.get(type.unannotated());
> 
> That way we'd be sure to always use the correct key and thus avoid
> duplication of equal annotated types.

I did it this way to scatter the types more sparsely. I am open to this being
changed along the lines your study and testing does not uncover any issues.
(In reply to Srikanth Sankaran from comment #25)

> [Entire TVB handling needs a relook. At the time clone is called, the
> prototype's instance fields are not initialized and we end up cloning
> them]

OK, I think I figured out a clean solution. The issues comes from the fact
that at the time of cloning to type annotate, the prototype TVB is not
connected, i.e its firstBound, superClass and superInterfaces have not been
computed yet. Subsequent to cloning the prototytpe evolves independently of
the clone. The fix should be propagate updates to the prototype to its clones.

I wish there was a way to tag a member as being public to clients, but only
as readonly. In the absence of it, we will have to trap all write accesses
into a method and leave a comment there.
(In reply to Srikanth Sankaran from comment #25)

> (2) Replace != and == with suitable wrappers.

This is tracked in bug 417803.

> (6)  We spoke about making the deep encoding configurable, so clients not
> interested in type annotations could avoid this overhead.
> Should this road be followed one fairly central spot to check for that
> switch would be inside BinaryTB where we create the TypeAnnotationWalker. If
> no annotations are requested the EMPTY_ANNOTATION_WALKER will do.

> (7) It should be clarified for all ATS#get*Type() methods, whether the
> primary input type can already be annotated.

> (10) Verify that annotated type binding uniqueness actually kicks in
> for marker annotated types. For others, we don't guarantee this. Perhaps
> we could extend this for single member annotations with default values,
> but this may not be worth it.
> 
> [See comment#16]

These are fixed here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=dfa40837336948a1f985e74dddef96333913f44c.

I switched ATS to use the unannotated type as the key in SLT, so the issue
mentioned in comment#16 is solved and we can guarantee identity for
equally annotated types as long as the annotations involved are marker
annotations or they have all default element value-pairs.

>(12) Make sure all TypeBinding classes implement copy constructors properly,
>in some of them clone directly does the work. For consistency we should
>change to one style.

I'll fold this into (1) which reads:
Another round of close scrutiny of the entire TypeBinding hierarchy.
Pending tasks not tracked elsewhere, reordered and renumbered.

(1) Another round of close scrutiny of the entire TypeBinding hierarchy.
In particular, where we store a prototype and delegate to it, make sure
the delegation makes sense. We already know of one instance STB#memberTypes
where it may not. In every type that stores a prototype, inspect all non-static
non-private methods to see (a) if delegation is called for and is in place
(b) delegation is not called for, but is incorrectly in place (c) where it 
guaranteed that a certain method would be invoked only on the declaration 
binding, insert an assert of sorts.

(2) NTAT#testConditional1 shows one fewer warnings, and a TODO links to another TODO in Scope#lowerUpperBound.
Failure to report the warning in question can be traced back to removal of these lines in ConditionalExpression#resolveType():

  if (use18specifics && valueIfTrueType != null && valueIfFalseType != null && valueIfTrueType != valueIfFalseType) {
	valueIfTrueType = valueIfTrueType.unannotated();
	valueIfFalseType = valueIfFalseType.unannotated();
  }

In order to follow the suggested road, I'd need to understand why handling this issue inside lub() is better than hiding type annotations from lub computation.

When re-inserting the deleted lines we may have to check if it requires some re-applying of dropped annotations so this.resolvedType won't lose necessary information. Maybe that's why those lines were deleted? OTOH, I'm afraid that letting lub() handle this might have unwanted effects during type inference?

(3) Address the sole failure. I think TVB should cache the prototype
and deflect - this is probably the reason for the failure in the disabled
test GrammarCoverageTests308._test023()

(4) Presently, wild card capture captures the unannotated wildcard and
then annotates the capture. In the process we lose the annotations on the
wildcard's bounds. Need to figure out what is the right thing here.

(5) LE#getTypeFromSignature: We are dropping annotations on enclosing types.
There is a comment to that effect in code.

(6) Re-review all overrides of Substitution.substitute(TypeVariableBinding)

(7) From comment#35: The following produces an NPE:
package p;
public class X <@Marker T extends @Marker Y<@Marker ?>, @Marker Q extends @Marker Integer> {
}
@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)
@interface Marker {}

This is the same test case from GrammarCoverageTests308#test022(), but occurs only when we are trying to resolve binding, I guess.
(In reply to Srikanth Sankaran from comment #47)

> (3) Address the sole failure. I think TVB should cache the prototype
> and deflect - this is probably the reason for the failure in the disabled
> test GrammarCoverageTests308._test023()

> (7) From comment#35: The following produces an NPE:
> package p;
> public class X <@Marker T extends @Marker Y<@Marker ?>, @Marker Q extends
> @Marker Integer> {
> }
> @java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)
> @interface Marker {}
> 
> This is the same test case from GrammarCoverageTests308#test022(), but
> occurs only when we are trying to resolve binding, I guess.


These two are addressed by commit http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=141285694dc186f382cdc5e23d991883a93f9f68 made for 
https://bugs.eclipse.org/bugs/show_bug.cgi?id=418041.

So I have (1), (2), (4), (5), (6) left to do
(In reply to Srikanth Sankaran from comment #47)
> (4) Presently, wild card capture captures the unannotated wildcard and
> then annotates the capture. In the process we lose the annotations on the
> wildcard's bounds. Need to figure out what is the right thing here.

This was straightforward: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=55e84c50cd008972a10ffc78185164e8a53def4f 

> (5) LE#getTypeFromSignature: We are dropping annotations on enclosing types.
> There is a comment to that effect in code.

Several issues in restoring annotations from class files addressed here:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=7f8c41fdd4e487762406a2cb6aaa3aa1d260201c  and

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=ddff8dde894947390c9a90bd347a6ae6239b2112 and

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=0e6d159b6b5bd2cefe41360d930f2e2ea9602f91

Open items:

(1) Review of TypeBinding hierarchy + Substitution implementations.

(2) lub computation in the presence of null annotations. This is a
non-issue for 308 annotations per se, since conditionals are not
exposed to a processor. But multicatch variables are and we need
to what the expectations on the type mirror there are.
(In reply to Srikanth Sankaran from comment #49)

> (2) lub computation in the presence of null annotations. 

I spawned https://bugs.eclipse.org/bugs/show_bug.cgi?id=418537 to address
this. 

I'll close the present after review of the TypeBinding hierarchy and
Substitution#substitute implementations.
(In reply to Stephan Herrmann from comment #0)

> (7) Investigate: To challenge whether delegation to prototype is OK in
> STB#memberTypes(): will annotated reference to member type @TA Outer.Inner
> see its Outer as @TA (at the binding level)?

This is proving to be an interesting problem. I am not sure there will
be legitimate client needs out there that would deep inspect traversing
back and forth the artifacts doled out of an annotated type binding.

memberTypes() is just one example. Many/most members retain a backpointer
to their declaring class. E.g: FieldBinding, MethodBinding, TypeVariableBinding
etc.

Creating a whole alternate universe is certainly possible, not even complicated
but is going to be memory intensive.

I am inclined to say we will cross the bridge when we get to it.

Stephan, Markus, Any thoughts ?
(In reply to Srikanth Sankaran from comment #51)

> Creating a whole alternate universe is certainly possible, not even
> complicated
> but is going to be memory intensive.

To illustrate with an example:

public class X {
   @NonNull X x;
}

1. So if you query the field x - what is your type ? You get @NonNull X
2. If you query @NonNull X - who are your fields ? you get a FieldBinding 'x'
3. If you query this field binding, who is your declaring class, you get X
and not @NonNull X.

This is per design as of now. This can be changed fairly straightforwardly
to answer @NonNull X. Spending a lot of memory in the process.

This is an issue only for those types that store a prototype and deflect
the queries (memberTypes(), getFields(), getMethods() etc) to the prototype.
This prototype model is used only for those types that can both have a
declaration site and a type use site.

Types that don't have a declaration site such as primitives, arrays,
parameterized types, raw types etc do not have this problem.

Types that can be only declared and not referenced i.e wildcards (anonymous)
and their captures do not also incur this issue.
Looking at the javadoc for TypeMirror, DeclaredType and TypeElement such
deep inspection is not required for type annotations by javax.lang.model. 
Even for generics such distinction is not called for. DeclaredType can
be queried for the TypeElement and the type arguments, i.e No instantiated type 


I see the following in org.eclipse.jdt.internal.compiler.apt.model.DeclaredTypeImpl.asElement()

@Override
public Element asElement() {
// The JDT compiler does not distinguish between type elements and declared types
  return _env.getFactory().newElement((ReferenceBinding)_binding,                                               
                                                        _elementKindHint);
}

and in Factory#newElement:

    case Binding.PARAMETERIZED_TYPE:
	return new TypeElementImpl(_env,   
          ((ParameterizedTypeBinding)binding).genericType(), kindHint);

Jay, let us do some experiments with 8b108 and see how the RI behaves.
(In reply to Srikanth Sankaran from comment #52)
> (In reply to Srikanth Sankaran from comment #51)

> To illustrate with an example:
> 
> public class X {
>    @NonNull X x;
> }
> 
> 1. So if you query the field x - what is your type ? You get @NonNull X
> 2. If you query @NonNull X - who are your fields ? you get a FieldBinding 'x'
> 3. If you query this field binding, who is your declaring class, you get X
> and not @NonNull X.

Sorry for the traffic, That was all muddled thinking brought about by lack
of sleep :) If the field binding answers @NonNull X for its declaring class
that would be totally wrong. The question is if you start with a field and
go to its type and from their get back to the field and from there get back
to its type whether one would see @NonNull X. This is the case and so there
is no issue here !
I have completed a full review as planned and released a bunch of commits
addressing all open issues and a handful of others found during code
review.

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=25ceba4552ce4df8b00117185ea4a4cf292544fd

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=e31e89499c545f3404d7787f4d333516631375ec

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=0eef8a719c726a9948e73db62c7f81adbce0f319 and

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=b54c3afd14262a683a389ccef497f8aa51da674c

Within the next week, I'll write up some final implementation notes for
posterity's sakes.
For completeness one partial rebuttal:

(In reply to Srikanth Sankaran from comment #51)
> (In reply to Stephan Herrmann from comment #0)
> 
> > (7) Investigate: To challenge whether delegation to prototype is OK in
> > STB#memberTypes(): will annotated reference to member type @TA Outer.Inner
> > see its Outer as @TA (at the binding level)?
> 
> ...
> 
> Creating a whole alternate universe is certainly possible, not even
> complicated
> but is going to be memory intensive.

I'd argue that your reasoning in comment 54 demonstrates a different thing.

Consider
  class X {
     String f;
  }
used in
  void test(@T X x) {
    x.f = null;
  }
If for some reason we'd be interested in knowing whether the declaring class of f has the @T annotation, the binding for x.f would not give away this information, its declaring class is just X. This situation could be forced if we accept @NonNullByDefault per TYPE_USE, but I have no plans of doing so, and thus JDT probably shouldn't bother.
 
> I am inclined to say we will cross the bridge when we get to it.

This I totally agree with :)
(In reply to Stephan Herrmann from comment #56)

> Consider
>   class X {
>      String f;
>   }
> used in
>   void test(@T X x) {
>     x.f = null;
>   }
> If for some reason we'd be interested in knowing whether the declaring class
> of f has the @T annotation, the binding for x.f would not give away this
> information, its declaring class is just X. 

But you can call getAnnotations on the field binding's declaring class. Wouldn't
that meet the need you cite ?
(In reply to Srikanth Sankaran from comment #57)
> (In reply to Stephan Herrmann from comment #56)
> 
> > Consider
> >   class X {
> >      String f;
> >   }
> > used in
> >   void test(@T X x) {
> >     x.f = null;
> >   }
> > If for some reason we'd be interested in knowing whether the declaring class
> > of f has the @T annotation, the binding for x.f would not give away this
> > information, its declaring class is just X. 
> 
> But you can call getAnnotations on the field binding's declaring class.
> Wouldn't
> that meet the need you cite ?

disclaimer: I haven't tried this, but: I expect that the STB for '@T X'
answers the fields from its prototype. So the declaring class for
'@T X.f' would be 'X', right? At that point getAnnotations() is of no help.
(In reply to Stephan Herrmann from comment #56)

> Consider
>   class X {
>      String f;
>   }
> used in
>   void test(@T X x) {
>     x.f = null;
>   }
> If for some reason we'd be interested in knowing whether the declaring class
> of f has the @T annotation, the binding for x.f would not give away this
> information, its declaring class is just X. 

OK, I think you meant to say, whether the object of which f is a field
has a @T annotated type. Yes, this is not answerable purely from
the type binding for x.f which is just the BTB for String. In fact even the
declaring class of x.f is not obtainable from the type binding for x.f.

But given:

// --
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target(ElementType.TYPE_USE)
@interface T {
	
}
class X {
     String f;
}

class Y {
	@T X xf;
	void test(@T X xp) {
	    xp.f = null;
	    xf.f = null;  
	}
}


From the field binding for xf.f or from the LocalVariableBinding for xp.f
one can determine that the X object was @T annotated.
(In reply to Srikanth Sankaran from comment #59)
> (In reply to Stephan Herrmann from comment #56)
> 
> > Consider
> >   class X {
> >      String f;
> >   }
> > used in
> >   void test(@T X x) {
> >     x.f = null;
> >   }
> > If for some reason we'd be interested in knowing whether the declaring class
> > of f has the @T annotation, the binding for x.f would not give away this
> > information, its declaring class is just X. 
> 
> OK, I think you meant to say, whether the object of which f is a field
> has a @T annotated type. Yes, this is not answerable purely from
> the type binding for x.f which is just the BTB for String. In fact even the
> declaring class of x.f is not obtainable from the type binding for x.f.

No, I wasn't speaking of the "type binding for x.f". "Binding for x.f" was meant to refer to the field binding.

> But given:
> 
> // --
> import java.lang.annotation.ElementType;
> import java.lang.annotation.Target;
> 
> @Target(ElementType.TYPE_USE)
> @interface T {
> 	
> }
> class X {
>      String f;
> }
> 
> class Y {
> 	@T X xf;
> 	void test(@T X xp) {
> 	    xp.f = null;
> 	    xf.f = null;  
> 	}
> }
> 
> 
> From the field binding for xf.f or from the LocalVariableBinding for xp.f
> one can determine that the X object was @T annotated.

If that is true than my worries are null & void.

I was under the impression that fields of an STB or BTB were never replicated due to annotations, and thus the single field binding for X.f would always name 'X' as its declaring class, never '@T X'. Am I missing anything?
(In reply to Stephan Herrmann from comment #60)

> > import java.lang.annotation.ElementType;
> > import java.lang.annotation.Target;
> > 
> > @Target(ElementType.TYPE_USE)
> > @interface T {
> > 	
> > }
> > class X {
> >      String f;
> > }
> > 
> > class Y {
> > 	@T X xf;
> > 	void test(@T X xp) {
> > 	    xp.f = null;
> > 	    xf.f = null;  
> > 	}
> > }

> I was under the impression that fields of an STB or BTB were never
> replicated due to annotations, and thus the single field binding for X.f
> would always name 'X' as its declaring class, never '@T X'. Am I missing
> anything?

(In reply to Stephan Herrmann from comment #60)
> (In reply to Srikanth Sankaran from comment #59)
> > (In reply to Stephan Herrmann from comment #56)
> > 
> > > Consider
> > >   class X {
> > >      String f;
> > >   }
> > > used in
> > >   void test(@T X x) {
> > >     x.f = null;
> > >   }
> > > If for some reason we'd be interested in knowing whether the declaring class
> > > of f has the @T annotation, the binding for x.f would not give away this
> > > information, its declaring class is just X. 
> > 
> > OK, I think you meant to say, whether the object of which f is a field
> > has a @T annotated type. Yes, this is not answerable purely from
> > the type binding for x.f which is just the BTB for String. In fact even the
> > declaring class of x.f is not obtainable from the type binding for x.f.
> 
> No, I wasn't speaking of the "type binding for x.f". "Binding for x.f" was
> meant to refer to the field binding.

OK, turns out the binding for x.f actually not a field binding, but is
a local variable binding that corresponds to x and from there I am able
to ascertain that x's type X was @T annotated.

I could verify that given the following program, at all 4 assignment
points, we are able to discriminate between the LHS and RHS wrt @T 
annotatedness.

// --
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target(ElementType.TYPE_USE)
@interface T {
	
}
class X {
     String f;
}

class Y {
	
	@T X xf1;
	X xf2;
	
	void test(@T X xp1, X xp2) {
	    xp1.f = xp2.f; 
	}
	void test2(X xp1, @T X xp2) { 
	    xp1.f = xp2.f; 
	}
	void test3() {
		xf1.f = xf2.f;
		xf2.f = xf1.f;  
	}
}

> I was under the impression that fields of an STB or BTB were never
> replicated due to annotations, and thus the single field binding for X.f
> would always name 'X' as its declaring class, never '@T X'. Am I missing
> anything?

Fields are not replicated. So the declaring class is always the same as
you outline. But there is enough contextual information in the QNR's
bindings to recover the @T annotatedness.

This discussion made me realize that we don't at this point share state
between 
 
   @NonNull List<@NonNull String>  and
            List<@NonNull String>

They have the same methods, fields, member types etc as the leftmost @NonNull
does not participate in substitutions.
(In reply to Srikanth Sankaran from comment #61)

> > No, I wasn't speaking of the "type binding for x.f". "Binding for x.f" was
> > meant to refer to the field binding.
> 
> OK, turns out the binding for x.f actually not a field binding, but is
> a local variable binding that corresponds to x and from there I am able
> to ascertain that x's type X was @T annotated.

This surprised me - for the 4th or 5th time in the last 5 years :)

It is queer modelling that the binding for the QNR x.f would actually be
an LVB and not an FB, but this has been so for more than a decade and I
am not about to wake up this sleeping dog :)
Working on type inference I discovered:
- an InferenceVariable (subclass of TypeVariableBinding) appeared twice as a key in a HashMap, assumably caused by:
- TypeBinding.hashCode relies on stability of TypeBinding.id
- UnannotatedTypeSystem lazily assigns ids, which violates stability

In that particular case I can workaround by either of:
- eagerly registering with UTS
- overriding hashCode() and equals()

Raising this issue here, because:
- the problem could potentially affect other subclasses of TypeBinding?
- the lone hashCode() looks strange without a matching equals()

@Srikanth, do you have reasons at hand, why the existing code is safe, or should I file a new bug?
(In reply to Stephan Herrmann from comment #63)

> @Srikanth, do you have reasons at hand, why the existing code is safe, or
> should I file a new bug?

Please do, I'll get on it right tomorrow. I had thought long and hard to
assure myself that this will never be a problem for the SLTs in UTS, ATS,
but obviously overlooked other areas where this could interfere, Thanks.

I have been meaning to move computeID() into TypeSystem and go for early
assignment of id stamps, this is a good motivation to work on it right away.
(In reply to Stephan Herrmann from comment #63)

> should I file a new bug?

I went ahead and raised https://bugs.eclipse.org/bugs/show_bug.cgi?id=419165.
Thanks.


[1.8][compiler] Encoding of type annotations in compiler bindings.



Follow up changes to Bug 417113 - [1.8][compiler] Encoding of type annotations in compiler bindings. 

[1.8] Follow ups to Bug 417113 - [1.8][compiler] Encoding of type annotations in compiler bindings. 
STR:

1) Open minefield using the jump list task item "Open privacy mode"

(This option uses the command line option 'privacy-toggle')

2) Once the browser opens, select the menu item 'Stop Private Browsing'

Result: nothing happens

In the console, there are a number of script errors:

startup:

Error: this._prefBranch is undefined
Source File: file:///C:/Program%20Files/Minefield/components/nsSessionStore.js
Line: 2692

Error: Exception thrown while processing the private browsing mode change request: [Exception... "'[JavaScript Error: "this._prefBranch is undefined" {file: "file:///C:/Program%20Files/Minefield/components/nsSessionStore.js" line: 2692}]' when calling method: [nsISessionStore::setBrowserState]"  nsresult: "0x80570021 (NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS)"  location: "JS frame :: file:///C:/Program%20Files/Minefield/components/nsPrivateBrowsingService.js :: PBS__onAfterPrivateBrowsingModeChange :: line 244"  data: yes]
Source File: file:///C:/Program%20Files/Minefield/components/nsPrivateBrowsingService.js
Line: 491

When selecting the menu item:

Error: uncaught exception: [Exception... "'Failure' when calling method: [nsIPrivateBrowsingService::privateBrowsingEnabled]"  nsresult: "0x80004005 (NS_ERROR_FAILURE)"  location: "JS frame :: chrome://browser/content/browser.js :: PBUI_toggleMode :: line 10160"  data: no]

STR:

1) Open minefield using the jump list task item "Open privacy mode"

(This option uses the command line option 'privacy-toggle')

2) Once the browser opens, select the menu item 'Stop Private Browsing'

Result: nothing happens

In the console, there are a number of script errors:

startup:

Error: this._prefBranch is undefined
Source File: file:///C:/Program%20Files/Minefield/components/nsSessionStore.js
Line: 2692

Error: Exception thrown while processing the private browsing mode change request: [Exception... "'[JavaScript Error: "this._prefBranch is undefined" {file: "file:///C:/Program%20Files/Minefield/components/nsSessionStore.js" line: 2692}]' when calling method: [nsISessionStore::setBrowserState]"  nsresult: "0x80570021 (NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS)"  location: "JS frame :: file:///C:/Program%20Files/Minefield/components/nsPrivateBrowsingService.js :: PBS__onAfterPrivateBrowsingModeChange :: line 244"  data: yes]
Source File: file:///C:/Program%20Files/Minefield/components/nsPrivateBrowsingService.js
Line: 491

When selecting the menu item:

Error: uncaught exception: [Exception... "'Failure' when calling method: [nsIPrivateBrowsingService::privateBrowsingEnabled]"  nsresult: "0x80004005 (NS_ERROR_FAILURE)"  location: "JS frame :: chrome://browser/content/browser.js :: PBUI_toggleMode :: line 10160"  data: no]
Created attachment 448086
WIP

This fix might not work just fine yet.  I fixed the jumplists code to use the correct param, and patched PB to init sessionstore, and used a lazy getter for _prefBranch in sessionstore.  My current Windows build is not quite useful for testing this, so I've pushed it to try server to test it more to make sure everything works correctly.
(In reply to comment #1)
> so I've pushed it to try server to test it more to make sure
> everything works correctly.

I didn't find a try build for this.
(In reply to comment #2)
> (In reply to comment #1)
> > so I've pushed it to try server to test it more to make sure
> > everything works correctly.
> 
> I didn't find a try build for this.

It didn't break any tests, but it doesn't work anyway yet... :-)
I'm wondering if we make this a blocker for FF4?
I guess we should, given the fact that we want to ship Firefox 4 with proper Windows 7 support.
What blocks here is making sure that if we offer a jumplist item, it works. If we can't make it work, we should not offer the jumplist item.
*** Bug 577212 has been marked as a duplicate of this bug. ***
*** Bug 585505 has been marked as a duplicate of this bug. ***
*** Bug 598572 has been marked as a duplicate of this bug. ***
Ehsan (who I like, no matter what he thinks) convinced me that this would be a high-value change and something that requires API churn so we should do it for beta7. He hopes to have a patch up shortly.
Created attachment 479664
Patch (v1)
Comment on attachment 479664
Patch (v1)

It appears that all that is really needed is a boolean for whether the last change to private browsing was performed by the command line which would be quite a bit simpler.
(In reply to comment #12)
> Comment on attachment 479664 [details]
> Patch (v1)
> 
> It appears that all that is really needed is a boolean for whether the last
> change to private browsing was performed by the command line which would be
> quite a bit simpler.

Yes, but I chose to use a multi-state value for the API so that we don't have to add a new attribute if we need to expose some other kind of state in the future.

Still, I can switch back to using a boolean attribute if you think this is the wrong approach.
Created attachment 479784
Patch (v1.1)

This version of the test includes a small fix to a cookie xpcshell test to make sure that it doesn't try to open a new window when going into the private browsing mode.
(In reply to comment #13)
> (In reply to comment #12)
> > Comment on attachment 479664 [details] [details]
> > Patch (v1)
> > 
> > It appears that all that is really needed is a boolean for whether the last
> > change to private browsing was performed by the command line which would be
> > quite a bit simpler.
> 
> Yes, but I chose to use a multi-state value for the API so that we don't have
> to add a new attribute if we need to expose some other kind of state in the
> future.
> 
> Still, I can switch back to using a boolean attribute if you think this is the
> wrong approach.
I think using a boolean is clearer and that adding support for possible future values isn't all that valuable and often requires reworking the API. I'd like to dolske to also weigh in as well.
Comment on attachment 479784
Patch (v1.1)

So, first up:

(In reply to comment #15)

> I think using a boolean is clearer and that adding support for possible future
> values isn't all that valuable and often requires reworking the API. I'd like
> to dolske to also weigh in as well.

Yeah, I agree that a boolean (to indicate if the command line started PB mode) would be clearer.


But I also find this patch confusing... I'm not really sure why things are being changed.

>+++ b/browser/components/nsBrowserGlue.js

>+#ifdef XP_WIN
>+#ifndef WINCE
>+    // For windows seven, initialize the jump list module.
>+    const WINTASKBAR_CONTRACTID = "@mozilla.org/windows-taskbar;1";
>+    if (WINTASKBAR_CONTRACTID in Cc &&
>+        Cc[WINTASKBAR_CONTRACTID].getService(Ci.nsIWinTaskbar).available) {
>+      let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
>+      timer.initWithCallback(function() {
>+        let temp = {};
>+        Cu.import("resource://gre/modules/WindowsJumpLists.jsm", temp);
>+        temp.WinTaskbarJumpList.startup();
>+      }, 1000, timer.TYPE_ONE_SHOT);
>+    }
>+#endif
>+#endif

Why are you moving this to earlier in startup [from _onBrowserStartup() to _onProfileStartup()], but also wrapping it in a 1 second timer? That would seem to make it start at an indeterminate time -- maybe it runs before _onBrowserStartup, maybe it runs after.


>+++ b/browser/components/privatebrowsing/src/nsPrivateBrowsingService.js
>         // Transition into private browsing mode
>         this._currentStatus = STATE_WAITING_FOR_RESTORE;
>+        ss.init(this._getBrowserWindow());
>         ss.setBrowserState(JSON.stringify(privateBrowsingState));

ss.init() seems like it can do some scary things if it's called at the wrong time (EG, STATE_QUITTING). Seems like it might be better for ss.setBrowserState to deal with this itself if needed? Would be good for a session store peer to weigh in on these changes!


>+++ b/browser/components/sessionstore/src/nsSessionStartup.js
>     // do not need to initialize anything in auto-started private browsing sessions
>     let pbs = Cc["@mozilla.org/privatebrowsing;1"].
>               getService(Ci.nsIPrivateBrowsingService);
>-    if (pbs.autoStarted)
>+    if (pbs.statusChangeReason == Ci.nsIPrivateBrowsingService.REASON_CHANGED_BY_CMDLINE)
>       return;

This seems to be the core fix? But if the commandline started private browsing, why isn't .autoStarted true here?

>+      Services.obs.removeObserver(this, "domwindowopened");
...
>-    Services.obs.removeObserver(this, "domwindowopened");

Why is this being moved?

The existing code is waiting for the first browser window to open, so there may be multiple domwindowopened notifications before _onWindowOpened() removes the observer. With your change the observer is removed after the first notification... So if the first window isn't a browser window, _onWindowOpened won't have done anything and never will.


>+++ b/browser/components/sessionstore/src/nsSessionStore.js
>@@ -148,6 +148,10 @@ function debug(aMsg) {
> /* :::::::: The Service ::::::::::::::: */
> 
> function SessionStoreService() {
>+  XPCOMUtils.defineLazyGetter(this, "_prefBranch", function() {
>+    return Services.prefs.getBranch("browser.")
>+                         .QueryInterface(Ci.nsIPrefBranch2);
>+  });

Lazy getters are fine and all, but for this to have any functional change (ie, I hope you're not just doing cleanup in a B7 blocker!) something would need to be calling session restore code before ss.init().... which seems bad.

>       case "private-browsing":
>-        this.update();
>+        Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer)
>+        .initWithCallback(this, 0, Ci.nsITimer.TYPE_ONE_SHOT);
>       break;

Why a timer?

This all vaguely feels a lot working around something else running at the wrong time by sprinkling some timeouts...
Also, I'm not sure this _really_ needs to be a B7 blocker. The API addition could be done in beta8 as a new nsIPBS_FF4BETA8 interface. Granted, that is a pain to do, so maybe what we should take for beta 7 is just the API change + minimal change to make the boolean report truthiness. The actual fix for the problem this bug covers could then be made at any point.
I don't really like the idea of pre-landing strings, or APIs. Can we get a Skype call together with the reviewers to have it happen in closer-to-realtime?
We can have a skype call but I think the following will end up being the course of action to take.

Since dolske and I both think the multi-state value approach is premature / unclear and Ehsan said he would switch back to the boolean approach I think that issue has been handled and the boolean approach should be implemented. I had only skimmed the code and was mainly doing an API sr (the only reason this patch needed an sr actually) and the above addresses that aspect. The comments from dolske should be responded to by Ehsan either by justifying the change or not making the change if it isn't necessary. If the session store changes are necessary Paul should also review the patch per dolske. With these things done I see no reason why the patch couldn't land soon after.
Comment on attachment 479784
Patch (v1.1)

>@@ -101,7 +101,7 @@ SessionStartup.prototype = {
>     // do not need to initialize anything in auto-started private browsing sessions
>     let pbs = Cc["@mozilla.org/privatebrowsing;1"].
>               getService(Ci.nsIPrivateBrowsingService);
>-    if (pbs.autoStarted)
>+    if (pbs.statusChangeReason == Ci.nsIPrivateBrowsingService.REASON_CHANGED_BY_CMDLINE)
>       return;

Just to make sure, pb.autoStarted is true when -private was on the command line, whereas REASON_CHANGED_BY_CMDLIN indicates either -private or -private-toggle.

We don't want to read the session from disk when either of these is invoked, right?

>@@ -197,6 +197,7 @@ SessionStartup.prototype = {
>         self._onWindowOpened(window);
>         window.removeEventListener("load", arguments.callee, false);
>       }, false);
>+      Services.obs.removeObserver(this, "domwindowopened");
>       break;
>     case "browser:purge-session-history":
>       // reset all state on sanitization
>@@ -236,8 +237,6 @@ SessionStartup.prototype = {
>     if (aWindow.arguments && aWindow.arguments[0] &&
>         aWindow.arguments[0] == defaultArgs)
>       aWindow.arguments[0] = null;
>-
>-    Services.obs.removeObserver(this, "domwindowopened");
>   },

Dolske's question as to why is a good one... I don't think it's as dangerous as he makes it sound though. You're just removing the observer sooner (right after the first domwindowopened) instead of waiting for the load event in that window (all windows fire a load event right, not just browser windows?). I don't see _why_ though.

> function SessionStoreService() {
>+  XPCOMUtils.defineLazyGetter(this, "_prefBranch", function() {
>+    return Services.prefs.getBranch("browser.")
>+                         .QueryInterface(Ci.nsIPrefBranch2);
>+  });
> }

Like Dolske said, the lazy getter shouldn't be necesary. Unless you're calling setBrowserState before init. In which case :(

>@@ -666,7 +667,9 @@ SessionStoreService.prototype = {
>       if (this._initialState) {
>         // make sure that the restored tabs are first in the window
>         this._initialState._firstTabs = true;
>-        this._restoreCount = this._initialState.windows ? this._initialState.windows.length : 0;
>+        if (!this._restoreCount) {
>+          this._restoreCount = this._initialState.windows ? this._initialState.windows.length : 0;
>+        }

I get that you're doing this because you're doing some tricksy stuff in setBrowserState to make session store think it's initial state is something it isn't. But I don't really like that.

>@@ -1002,6 +1005,12 @@ SessionStoreService.prototype = {
> 
>     var window = this._getMostRecentBrowserWindow();
>     if (!window) {
>+      var ss = Cc["@mozilla.org/browser/sessionstartup;1"].
>+               getService(Ci.nsISessionStartup);
>+      if (ss.sessionType == Ci.nsISessionStartup.NO_SESSION &&
>+          !ss.state) {
>+        this._initialState = aState;
>+      }
>       this._restoreCount = 1;
>       this._openWindowWithState(state);
>       return;

I don't like this at all. So AIUI, you're trying to shoehorn the state passed in to _initialState so that it will be used in onLoad (I'm not completely sure how all of this is working, but I assume state was STATE_STOPPED? so that's why we would even be there). Calling _openWindowWithState won't get to what you're expecting it to because we're at STATE_STOPPED so we won't actually restore the window otherwise. Doesn't calling init() put us into STATE_RUNNING and this isn't needed?

I agree with Dolske that this seems a bit like there's a problem being worked around.

No r+ from me yet. I need more convincing.
(In reply to comment #20)

> >-    Services.obs.removeObserver(this, "domwindowopened");
> 
> Dolske's question as to why is a good one... I don't think it's as dangerous as
> he makes it sound though. You're just removing the observer sooner (right after
> the first domwindowopened) instead of waiting for the load event in that window
> (all windows fire a load event right, not just browser windows?). 

The |load| listener is added per-windows when |domwindowopened| fires. So if you only listen for 1 domwindowopened, you'll only listen 1 for load.
Ah I skipped that part of _onWindowOpened where it returns early if its not a navigator:browser
(In reply to comment #16)
> Comment on attachment 479784
>   --> https://bugzilla.mozilla.org/attachment.cgi?id=479784
> Patch (v1.1)
> 
> So, first up:
> 
> (In reply to comment #15)
> 
> > I think using a boolean is clearer and that adding support for possible future
> > values isn't all that valuable and often requires reworking the API. I'd like
> > to dolske to also weigh in as well.
> 
> Yeah, I agree that a boolean (to indicate if the command line started PB mode)
> would be clearer.

OK, I'll make that change.

> But I also find this patch confusing... I'm not really sure why things are
> being changed.

I don't blame you.  The reason is that throughout writing this patch, I found a lot of broken stuff which I fixed.  I'll describe each below.

> >+++ b/browser/components/nsBrowserGlue.js
> 
> >+#ifdef XP_WIN
> >+#ifndef WINCE
> >+    // For windows seven, initialize the jump list module.
> >+    const WINTASKBAR_CONTRACTID = "@mozilla.org/windows-taskbar;1";
> >+    if (WINTASKBAR_CONTRACTID in Cc &&
> >+        Cc[WINTASKBAR_CONTRACTID].getService(Ci.nsIWinTaskbar).available) {
> >+      let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
> >+      timer.initWithCallback(function() {
> >+        let temp = {};
> >+        Cu.import("resource://gre/modules/WindowsJumpLists.jsm", temp);
> >+        temp.WinTaskbarJumpList.startup();
> >+      }, 1000, timer.TYPE_ONE_SHOT);
> >+    }
> >+#endif
> >+#endif
> 
> Why are you moving this to earlier in startup [from _onBrowserStartup() to
> _onProfileStartup()], but also wrapping it in a 1 second timer? That would seem
> to make it start at an indeterminate time -- maybe it runs before
> _onBrowserStartup, maybe it runs after.

Well, _onBrowserStartup is a misnomer, and it should really be called _onSessionRestored or something.  We call this function when sessionstore restores a session (on sessionstore-windows-restored), which means that if for whatever reason (for example, starting in private browsing mode) a session is not restored, it's not called at all.  This results in the jumplist feature not working correctly if you start in private browsing mode.  (By not working correctly I mean not being initialized, and Firefox showing the same jumplist items as it did the last time it ran.)

Now, the reason I moved it to _onProfileStartup is that function is guaranteed to run every time that Firefox starts up.  The reason that I set a timeout (dirty dirty trick, not proud of it) is that we need some window to be displayed when the jumplist feature is being initialized.  What I really wanted was a notification that would fire when the browser has done starting up (whether a session being restored or not), but I don't know of any such notifications...

Something just occured to me, and I'm not sure if it works correctly or not.  How about we call nsISessionStartup.doRestore on final-ui-startup, and based on its return value either listen for sessionstore-windows-restored or browser-delayed-startup-finished?  Would that be a better solution?

> >+++ b/browser/components/privatebrowsing/src/nsPrivateBrowsingService.js
> >         // Transition into private browsing mode
> >         this._currentStatus = STATE_WAITING_FOR_RESTORE;
> >+        ss.init(this._getBrowserWindow());
> >         ss.setBrowserState(JSON.stringify(privateBrowsingState));
> 
> ss.init() seems like it can do some scary things if it's called at the wrong
> time (EG, STATE_QUITTING). Seems like it might be better for ss.setBrowserState
> to deal with this itself if needed? Would be good for a session store peer to
> weigh in on these changes!

In this particular case, it's not possible for the browser to be in quitting state (well, unless an add-on makes us enter PB mode at quit-application-granted or something).  I'm not sure how setBrowserState is going to take care of this.

> >+++ b/browser/components/sessionstore/src/nsSessionStartup.js
> >     // do not need to initialize anything in auto-started private browsing sessions
> >     let pbs = Cc["@mozilla.org/privatebrowsing;1"].
> >               getService(Ci.nsIPrivateBrowsingService);
> >-    if (pbs.autoStarted)
> >+    if (pbs.statusChangeReason == Ci.nsIPrivateBrowsingService.REASON_CHANGED_BY_CMDLINE)
> >       return;
> 
> This seems to be the core fix? But if the commandline started private browsing,
> why isn't .autoStarted true here?

.autoStarted will only be true if you use -private (as it indicated permanent PB mode, and can be true if you set the corresponding pref to true no matter what's on the command line).  -private-toggle does not imply that .autoStarted == true.

Oh, and yes, this is the core fix!

> >+      Services.obs.removeObserver(this, "domwindowopened");
> ...
> >-    Services.obs.removeObserver(this, "domwindowopened");
> 
> Why is this being moved?

Because there could be multiple windows being opened, and all but the first one's load event will cause this to throw.

> The existing code is waiting for the first browser window to open, so there may
> be multiple domwindowopened notifications before _onWindowOpened() removes the
> observer. With your change the observer is removed after the first
> notification... So if the first window isn't a browser window, _onWindowOpened
> won't have done anything and never will.

Hmm, you're right.  Is the type of window available before the load event?

> >+++ b/browser/components/sessionstore/src/nsSessionStore.js
> >@@ -148,6 +148,10 @@ function debug(aMsg) {
> > /* :::::::: The Service ::::::::::::::: */
> > 
> > function SessionStoreService() {
> >+  XPCOMUtils.defineLazyGetter(this, "_prefBranch", function() {
> >+    return Services.prefs.getBranch("browser.")
> >+                         .QueryInterface(Ci.nsIPrefBranch2);
> >+  });
> 
> Lazy getters are fine and all, but for this to have any functional change (ie,
> I hope you're not just doing cleanup in a B7 blocker!) something would need to
> be calling session restore code before ss.init().... which seems bad.

Oh, this is not a cleanup at all!  :-)

So the reason that I did it in the first place was that PB could be calling into sessionstore's functions before init (which is another misnomer, should have been called startTrackingAWindow or something, the only thing that this function doesn't do is initialize the sessionstore service!) is called, and this would call this._prefBranch to throw.  Now, the way that sessionstore's init is called <http://mxr.mozilla.org/mozilla-central/source/browser/base/content/browser.js#1490>, there is absolutely nothing preventing other code from calling its other functions before init has been called for the first time, hence this change (FWIW, I've seen that error message in real browsing sessions quite a few times, but have never been able to track down a set of STRs and file a bug on them).

> >       case "private-browsing":
> >-        this.update();
> >+        Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer)
> >+        .initWithCallback(this, 0, Ci.nsITimer.TYPE_ONE_SHOT);
> >       break;
> 
> Why a timer?
> 
> This all vaguely feels a lot working around something else running at the wrong
> time by sprinkling some timeouts...

Oh, this one is something which I was giving a shot at, and just slipped into the final version of the patch.  I'll revert this hunk.
(In reply to comment #20)
> Comment on attachment 479784
>   --> https://bugzilla.mozilla.org/attachment.cgi?id=479784
> Patch (v1.1)
> 
> >@@ -101,7 +101,7 @@ SessionStartup.prototype = {
> >     // do not need to initialize anything in auto-started private browsing sessions
> >     let pbs = Cc["@mozilla.org/privatebrowsing;1"].
> >               getService(Ci.nsIPrivateBrowsingService);
> >-    if (pbs.autoStarted)
> >+    if (pbs.statusChangeReason == Ci.nsIPrivateBrowsingService.REASON_CHANGED_BY_CMDLINE)
> >       return;
> 
> Just to make sure, pb.autoStarted is true when -private was on the command
> line, whereas REASON_CHANGED_BY_CMDLIN indicates either -private or
> -private-toggle.

True.

> We don't want to read the session from disk when either of these is invoked,
> right?

Yes.

> >@@ -197,6 +197,7 @@ SessionStartup.prototype = {
> >         self._onWindowOpened(window);
> >         window.removeEventListener("load", arguments.callee, false);
> >       }, false);
> >+      Services.obs.removeObserver(this, "domwindowopened");
> >       break;
> >     case "browser:purge-session-history":
> >       // reset all state on sanitization
> >@@ -236,8 +237,6 @@ SessionStartup.prototype = {
> >     if (aWindow.arguments && aWindow.arguments[0] &&
> >         aWindow.arguments[0] == defaultArgs)
> >       aWindow.arguments[0] = null;
> >-
> >-    Services.obs.removeObserver(this, "domwindowopened");
> >   },
> 
> Dolske's question as to why is a good one... I don't think it's as dangerous as
> he makes it sound though. You're just removing the observer sooner (right after
> the first domwindowopened) instead of waiting for the load event in that window
> (all windows fire a load event right, not just browser windows?). I don't see
> _why_ though.

See my reply in comment 23.  You can't remove an observer after it's been removed once, and there is nothing preventing this load event handler to be called multiple times on multiple windows.

> > function SessionStoreService() {
> >+  XPCOMUtils.defineLazyGetter(this, "_prefBranch", function() {
> >+    return Services.prefs.getBranch("browser.")
> >+                         .QueryInterface(Ci.nsIPrefBranch2);
> >+  });
> > }
> 
> Like Dolske said, the lazy getter shouldn't be necesary. Unless you're calling
> setBrowserState before init. In which case :(

Yes, that's what was happening in this case, *but* as I pointed out in comment 23, you shouldn't really think of init as the initializer for the sessionstore service, because, well, it's not!  It's possible to use the sessionstore service before init is called in so many ways.

> >@@ -666,7 +667,9 @@ SessionStoreService.prototype = {
> >       if (this._initialState) {
> >         // make sure that the restored tabs are first in the window
> >         this._initialState._firstTabs = true;
> >-        this._restoreCount = this._initialState.windows ? this._initialState.windows.length : 0;
> >+        if (!this._restoreCount) {
> >+          this._restoreCount = this._initialState.windows ? this._initialState.windows.length : 0;
> >+        }
> 
> I get that you're doing this because you're doing some tricksy stuff in
> setBrowserState to make session store think it's initial state is something it
> isn't. But I don't really like that.

No, this code was just wrong.  Here's what happens.

In setBrowserState, we set _restoreCount to the number of windows to be restored, so that we can fire sessionstore-browser-state-restored in time (the PB service relies on that notification).  What the code in question does is overwrite _restoreCount without regard to whether it's been set by setBrowserState.  The only case where _restoreCount in this case can be non-zero is if setBrowserState is called directly the way that the PB service uses it, that's why this problem was never uncovered before, I think.

> >@@ -1002,6 +1005,12 @@ SessionStoreService.prototype = {
> > 
> >     var window = this._getMostRecentBrowserWindow();
> >     if (!window) {
> >+      var ss = Cc["@mozilla.org/browser/sessionstartup;1"].
> >+               getService(Ci.nsISessionStartup);
> >+      if (ss.sessionType == Ci.nsISessionStartup.NO_SESSION &&
> >+          !ss.state) {
> >+        this._initialState = aState;
> >+      }
> >       this._restoreCount = 1;
> >       this._openWindowWithState(state);
> >       return;
> 
> I don't like this at all. So AIUI, you're trying to shoehorn the state passed
> in to _initialState so that it will be used in onLoad (I'm not completely sure
> how all of this is working, but I assume state was STATE_STOPPED? so that's why
> we would even be there).

Yes, this happens when you start Firefox in private browsing mode, which means that the state is STATE_STOPPED, and setBrowserState is called by the PB service.

> Calling _openWindowWithState won't get to what you're
> expecting it to because we're at STATE_STOPPED so we won't actually restore the
> window otherwise. Doesn't calling init() put us into STATE_RUNNING and this
> isn't needed?

Hmm, am I missing something?  init doesn't change our state, it's onLoad which puts us into STATE_RUNNING if we're STATE_STOPPED, right?

Reading the code again, I think that this is the code responsible for restoring the window <http://mxr.mozilla.org/mozilla-central/source/browser/components/sessionstore/src/nsSessionStore.js#689>, and it's obviously not called at all if we're STATE_STOPPED.  Sigh...

> I agree with Dolske that this seems a bit like there's a problem being worked
> around.

Of course.  The problem that I'm trying to work around is that setBrowserState does not do what it says that it's going to do!  :-)

setBrowserState fails to finish restoring windows, which causes the transition of the PB mode not to be completed, which causes the PB service to remain in an intermediate state, which causes you not be able to switch out of the PB mode, which results in the behavior in comment 0.  Note that this was only uncovered after I did the "core fix".

I'm not sure how else to address this problem.  Maybe setBrowserState should switch us to STATE_RUNNING?  Not sure.  I've had this problem with sessionstore code before; it's really only assuming a single use case (saving the status of the browser when running and restoring that saved session later on) in various places, and the setBrowserState, which is an entirely different use case, fails to interact correctly with the rest of the service in various ways (for example, the only state which really makes sense to check for setBrowserState is STATE_QUITTING maybe; STATE_STOPPED and STATE_RUNNING are really concepts which *only* map to the first use case...)

Suggestions welcome!  :-)
(In reply to comment #21)
> (In reply to comment #20)
> 
> > >-    Services.obs.removeObserver(this, "domwindowopened");
> > 
> > Dolske's question as to why is a good one... I don't think it's as dangerous as
> > he makes it sound though. You're just removing the observer sooner (right after
> > the first domwindowopened) instead of waiting for the load event in that window
> > (all windows fire a load event right, not just browser windows?). 
> 
> The |load| listener is added per-windows when |domwindowopened| fires. So if
> you only listen for 1 domwindowopened, you'll only listen 1 for load.

Not at all.  Before my patch, you're listening for N domwindowopened's.  If you're lucky (which is often the case), you only get 1, so you'll be listening for 1 load.  If you're not lucky, you'll get 2 or more, which means that you'll be lisetning for N>1 loads, which means that you'll get N-1 throws when removing the observer.
Created attachment 480127
Patch (v2)

Switched to using a simple boolean API to determine whether the private browsing service has been started from the command line or not, and also removed one unneeded hunk (see the end of comment 23).
Comment on attachment 480127
Patch (v2)

Only reviewing the API part of the patch

>diff --git a/netwerk/base/public/nsIPrivateBrowsingService.idl b/netwerk/base/public/nsIPrivateBrowsingService.idl
>--- a/netwerk/base/public/nsIPrivateBrowsingService.idl
>+++ b/netwerk/base/public/nsIPrivateBrowsingService.idl
>@@ -37,7 +37,7 @@
> 
> #include "nsISupports.idl"
> 
>-[scriptable, uuid(49d6f133-80c0-48c7-876d-0b70bbfd0289)]
>+[scriptable, uuid(4b731983-9542-49f4-b16b-de68ad1c2068)]
> interface nsIPrivateBrowsingService : nsISupports
> {
>     // When read, determines whether the private browsing mode is currently
>@@ -52,6 +52,10 @@ interface nsIPrivateBrowsingService : ns
>     // This value will never be true if privateBrowsingEnabled is false.
>     readonly attribute boolean autoStarted;
> 
>+    // Determine whether the last private browsing transition was performed through
>+    // the command line (using either the -private or -private-toggle switches).
>+    readonly attribute boolean launchedFromCommandLine;
I think lastChangedByCommandLine is much more self explanatory.

sr=me with that
Comment on attachment 480127
Patch (v2)

Per our chat, r- on this approach. I'm quite against the idea of tricking session restore. So the problem is going to be fixed more correctly.

Part of the problem is that even though init is being called, it's being called without a window, so it bails out immediately without actually initializing the service. That's why the lazy pref branch is needed. And also why the hack around the _initialState is needed.

Ehsan is going to do this more correctly by separating what actually inits the service and call that from the c'tor. He'll handle the null window case that is contained to him. All-in-all, it should be much better.
Created attachment 480206
Patch (v3)

This version of the patch changed the following:

* Addressed comment 27.
* Addressed comment 28.
* Implemented my nsBrowserGlue related suggestion in comment 23.
* Switched to update the jumplist when it's initialized event if we're not in the PB mode, so that if Firefox is closed during private browsing, the next time that we startup, we wouldn't show "Quit Private Browsing" in the jumplist menu for 7 minutes.  :-)
Comment on attachment 480206
Patch (v3)

>+  init: function sss_init(aWindow) {
>+    if (!aWindow || this._loadState == STATE_RUNNING) {
>+      // make sure that all browser windows which try to initialize
>+      // SessionStore are really tracked by it
>+      if (aWindow && (!aWindow.__SSi || !this._windows[aWindow.__SSi]))
>+        this.onLoad(aWindow);

Can you add a comment here about this case (since the comment above doesn't apply to this)

>+      if (!aWindow && this._loadState == STATE_STOPPED)
>+        this._loadState = STATE_RUNNING;
>+      return;
>+    }
>+
>     // As this is called at delayedStartup, restoration must be initiated here
>     this.onLoad(aWindow);
>   },

r=zpao with that.
I filed bug 601255 as a follow-up to hide the PB jumplist entry when permanent PB mode is active.
Comment on attachment 480206
Patch (v3)

Already commented on this in IRC, but FTR:

>+  // the first browser window has finished initializing
>+  _onFirstWindowLoaded: function BG__onFirstWindowLoaded() {
>+#ifdef XP_WIN
>+#ifndef WINCE
>+    // For windows seven, initialize the jump list module.
>+    const WINTASKBAR_CONTRACTID = "@mozilla.org/windows-taskbar;1";
>+    if (WINTASKBAR_CONTRACTID in Cc &&
>+        Cc[WINTASKBAR_CONTRACTID].getService(Ci.nsIWinTaskbar).available) {
>+      let timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
>+      timer.initWithCallback(function() {
>+        let temp = {};
>+        Cu.import("resource://gre/modules/WindowsJumpLists.jsm", temp);
>+        temp.WinTaskbarJumpList.startup();
>+      }, 1000, timer.TYPE_ONE_SHOT);
>+    }

Moving this is ok, but the timer wrapper isn't needed.

>         if (browserWindow) {
>           // set an empty session to transition from/to pb mode, see bug 476463
>+          ss.init(browserWindow);

These .init()s are only needed when there's no browser, so this one can be removed (it's checked a 2 lines up), and the others can be:

  if (!this._getBrowserWindow())
    ss.init(null);

I agree with gavin, though, that ss should just be able to handle this case itself. File a followup? [Since there are likely other SS APIs that should self-init too.]

>+++ b/browser/components/sessionstore/src/nsSessionStartup.js
>@@ -101,7 +101,7 @@ SessionStartup.prototype = {
>     // do not need to initialize anything in auto-started private browsing sessions
>     let pbs = Cc["@mozilla.org/privatebrowsing;1"].
>               getService(Ci.nsIPrivateBrowsingService);
>-    if (pbs.autoStarted)
>+    if (pbs.lastChangedByCommandLine)

Should be (pbs.autoStarted || pbs.lastChangedByCommandLine) or you break Permanent PB Mode.

>+      Services.obs.removeObserver(this, "domwindowopened");

try/catch this instead of moving, per previous comments.
Switching in-litmus request to Marcia. Ehsan, as a side-note she is managing this subgroup. :)
Created attachment 480265
Patch (v4)

With all of the comments addressed.
(In reply to comment #32)
> I agree with gavin, though, that ss should just be able to handle this case
> itself. File a followup? [Since there are likely other SS APIs that should
> self-init too.]

Filed bug 601272.
Comment on attachment 480265
Patch (v4)


>+++ b/browser/components/nsBrowserContentHandler.js
...
>+    os.addObserver(this, "browser-delayed-startup-finished", false);

Nit: remove the observer too, as is done with all the others down in _dispose().


>+++ b/browser/components/sessionstore/src/nsSessionStore.js
>@@ -148,6 +148,7 @@ function debug(aMsg) {
> /* :::::::: The Service ::::::::::::::: */
> 
> function SessionStoreService() {
>+  this.initService();
> }

Hmm, so, I did some extra checking to see that this is safe, since (most) of the former init() code now runs as soon as this service is created...

initService() calls the nsISessionStartup service, but that service doesn't init itself until final-ui-startup. Can we guarantee nothing does/will create the SS service until after that? (Rhetorical: not sure we can, so seems like either nsSessionStatup needs to init earlier, or this part of nsSessionStartup needs to be able to defer that work.)
(In reply to comment #36)
> initService() calls the nsISessionStartup service, but that service doesn't
> init itself until final-ui-startup. Can we guarantee nothing does/will create
> the SS service until after that? (Rhetorical: not sure we can, so seems like
> either nsSessionStatup needs to init earlier, or this part of nsSessionStartup
> needs to be able to defer that work.)

It seems that nsICommandLineRunner::Run is executed after final-ui-startup: <http://mxr.mozilla.org/mozilla-central/source/toolkit/xre/nsAppRunner.cpp#3644>
Created attachment 480294
Patch (v5)
Comment on attachment 480294
Patch (v5)

>+      case "browser-delayed-startup-finished":
>+        this._onFirstWindowLoaded();
>+        Services.obs.removeObserver(this, "browser-delayed-startup-finished");
>+        break;
...
>+    os.addObserver(this, "browser-delayed-startup-finished", false);

Sigh. I didn't notice you already had a removeObserver in my last comment, and as you noted removing this observer in _dispose() is incorrect.

The initialization changes to nsSessionStore.js address my previous concerns, per IRC.

r+ with undoing my bad removeObserver nit. :)
Created attachment 480301
For check-in
I'll land it during the weekend if nobody beats me to it before then.
Created attachment 480309
For check-in

Included the a= token in the commit message.
http://hg.mozilla.org/mozilla-central/rev/b08b684644a1
I backed this out because of huge Ts regressions on Windows.

Regression :( Ts increase 4.7% on Win7 Firefox
----------------------------------------------
    Previous: avg 484.077 stddev 6.402 of 30 runs up to revision 286d3026ae20
    New     : avg 506.832 stddev 3.429 of 5 runs since revision b08b684644a1
    Change  : +22.754 (4.7% / z=3.554)
    Graph   : http://mzl.la/dxEVMS

Regression :( Ts, MAX Dirty Profile increase 382% on Win7 Firefox
-----------------------------------------------------------------
    Previous: avg 489.749 stddev 16.115 of 30 runs up to revision 286d3026ae20
    New     : avg 2359.378 stddev 24.374 of 5 runs since revision b08b684644a1
    Change  : +1869.629 (382% / z=116.019)
    Graph   : http://mzl.la/aaKfSk

Regression :( Ts, MED Dirty Profile increase 54.5% on Win7 Firefox
------------------------------------------------------------------
    Previous: avg 484.830 stddev 4.108 of 30 runs up to revision 286d3026ae20
    New     : avg 749.263 stddev 8.083 of 5 runs since revision b08b684644a1
    Change  : +264.433 (54.5% / z=64.372)
    Graph   : http://mzl.la/aey4UL

Regression :( Ts, Cold MED Dirty Profile increase 53% on Win7 Firefox
---------------------------------------------------------------------
    Previous: avg 490.911 stddev 19.762 of 30 runs up to revision 286d3026ae20
    New     : avg 751.137 stddev 11.576 of 5 runs since revision b08b684644a1
    Change  : +260.226 (53% / z=13.168)
    Graph   : http://mzl.la/avzB0x

Regression :( Ts, Cold MAX Dirty Profile increase 384% on Win7 Firefox
----------------------------------------------------------------------
    Previous: avg 488.725 stddev 5.192 of 30 runs up to revision 286d3026ae20
    New     : avg 2366.210 stddev 26.505 of 5 runs since revision b08b684644a1
    Change  : +1877.485 (384% / z=361.584)
    Graph   : http://mzl.la/9dGvsQ


This is really puzzling, because as far as I can tell, no part of the changes in this patch should be on the startup path...

I'll investigate this tomorrow, but if I can't figure out the cause quickly, I guess the way to go here is to land the API addition separately for beta7 and take the rest of the fix later.
These are somewhat similar to the Ts gains we got by avoiding the initial jl update for thirty seconds. Doesn't look like this patch triggered that though. But for reference - bug 594821, and bug 598229 relates to improving the performance of the favorites db queries.
Ehsan, I can't actually see us holding Beta 7 for this bug. Should we switch the to non-breaking-API mechanism for this change?
(In reply to comment #46)
> Ehsan, I can't actually see us holding Beta 7 for this bug. Should we switch
> the to non-breaking-API mechanism for this change?

We could, but what's wrong with just landing the new API right now?  I can even file a new bug for that if that's better.
Beltzner told me in person that we can take the API changes for beta7 if needed, but I think I have tracked down the regression source, so I'll probably reland the whole thing again today.

See my next comment for more info!
Created attachment 480682
Ts-safe version of the patch

So, my local tests confirmed that this hunk is the cause of the regression: http://hg.mozilla.org/mozilla-central/rev/b08b684644a1#l12.12

This is kind of exactly like an instance of bug 594821.  I'm taking this hunk out of this patch and I'll post a new patch containing only that hunk on bug 598229 (which is supposed to make the queries fast and all).
Relanded: http://hg.mozilla.org/mozilla-central/rev/98a818bf5786
https://litmus.mozilla.org/show_test.cgi?id=13615 added to Litmus.
Was the net result of this no API change then?
(In reply to comment #52)
> Was the net result of this no API change then?

No.  The lastChangedByCommandLine attribute was added to nsIPrivateBrowsingService.
Updated documentation:

https://developer.mozilla.org/En/NsIPrivateBrowsingService


Switching out of privacy mode fails when privacy mode is invoked by Windows 7 jumplist (via the command line option 'privacy-toggle')

dev-doc-complete

Bug 568816 - Switching out of privacy mode fails when privacy mode is enabled via the command line option 'privacy-toggle'; r=zpao,dolske sr=rstrong a=blocking-beta7+ 

Backed out changeset b08b684644a1 (bug 568816) because of Ts regression on Windows 

Merge backout of bug 568816; a=me 

Bug 568816 - Switching out of privacy mode fails when privacy mode is enabled via the command line option 'privacy-toggle'; r=zpao,dolske,jimm sr=rstrong a=blocking-beta7+ 